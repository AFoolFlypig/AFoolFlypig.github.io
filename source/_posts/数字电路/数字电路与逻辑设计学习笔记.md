---
title: 数字电路与逻辑设计学习笔记
date: 2020-01-03 19:11:32
categories: 数字电路
mathjax: true
tags: 
- 数电
---
我最近在跟着慕课学习数电,把平时所学的一些东西和自己的一些理解整理到这里
<!--more-->

第一章 基本知识
======
1.1 数字信号与系统
------
下面先介绍几个概念.
**模拟信号**:信号的变化在时间和数值上都是**连续的**.
**离散信号**:信号的变化在时间和数值上都是**离散的**,或者说断续的.离散信号的变化可以用不同的数字反映,所以又称**数字信号**.
**数字系统**:数字系统是一个能对数字信号进行加工、传递和存储的实体,它由实现各种功能的数字逻辑电路相互连接而成.
由于现实世界中的信号多为模拟信号,而模拟信号并不易于处理,需要将其转换为数字信号进行处理,然后再将其还原为模拟信号.
二者之间的相互转换为**A/D-模数转换(Analog-Digital)**,**D/A-数模转换(Digital-Analog)**.
模拟信号数字化的主要步骤为**采样(Sampling)、量化(Quantization)与编码(Encoding)**.如下图所示:

{% asset_img chapter1/图1-1.png %}
{% asset_img chapter1/图1-2.png %}
{% asset_img chapter1/图1-3.png %}
数字系统的示例:
{% asset_img chapter1/图1-4.png %}
**数字电路**是用来处理数字信号的电子线路.由于数字电路的各种功能是通过逻辑运算和逻辑判断来实现的,所以数字电路又称为**数字逻辑电路**或者**逻辑电路**.
数字逻辑电路的特点:

+ 电路的基本工作信号是二值信号.
+ 电路中的半导体器件一般都在开、关状态.

数字系统的层次结构如下图:
{% asset_img chapter1/图1-5.png %}
第2级为小规模集成电路,第3级为中、大规模集成电路,第4级为超大规模集成电路.
根据一个电路有无记忆功能,可以将数字逻辑电路分为**组合逻辑电路(Combinational Logic Circuit)**(无记忆功能)和**时序逻辑电路(Sequential Logic Circuit)**(有记忆功能).
**组合逻辑电路**:在任何时刻的稳定输出仅取决于该时刻的输入,而与电路过去的输入无关.
**时序逻辑电路**按照是否有统一的时钟信号进行同步,可分为**同步时序逻辑电路**和**异步时序逻辑电路**.

1.2 数制及其转换
------
在生活中我们主要使用的是十进制,而在计算机中使用的是二进制,主要是因为二进制有如下特点:
{% asset_img chapter1/图1-6.png %}
下面是二进制与其他进制的转换方法:
{% asset_img chapter1/图1-7.png %}
{% asset_img chapter1/图1-8.png %}
{% asset_img chapter1/图1-9.png %}
其中,二进制转八进制或十六进制时,若不够三位或四位,则补0凑足.

1.3 带符号二进制数的代码表示
------
在机器中带符号的数采取如下的表示方法:
{% asset_img chapter1/图1-10.png %}
常用的机器码有原码、反码和补码,下面一一进行介绍.

### 1.3.1 原码
最左侧的一位为**符号位**,数码0表示正号,数码1表示负号,其余的为**数值位**,为真值的绝对值.简言之,原码即为**符号位+真值绝对值**
原码的标准化定义如下:
{% asset_img chapter1/图1-11.png %}
其实不用管上面的定义,只需要会原码怎么算就可以了.
示例:
> x=+1101	[x]<sub>原</sub>=01101
x=-1101	[x]<sub>原</sub>=11101
x=0.1011	[x]<sub>原</sub>=0.1011
x=-0.1011	[x]<sub>原</sub>=1.1011

原码表示法的特点:
{% asset_img chapter1/图1-12.png %}
**原码不能直接进行减法运算**.那么有没有一种编码能够使减法变加法,符号位直接参与运算呢?

### 1.3.2 反码
{% asset_img chapter1/图1-13.png %}
反码的标准化定义如下:
{% asset_img chapter1/图1-14.png %}
示例:
> x=+0.1011	[x]<sub>反</sub>=0.1011
x=-0.1011	[x]<sub>反</sub>=1.0100
[+0]<sub>反</sub> =0.00...0
[-0]<sub>反</sub> =1.11...1

但是反码仍然没有解决减法问题和正负0问题,如上例.

### 1.3.3 补码
在介绍补码之前,先要介绍"模"的概念.
**"模"**是指一个计量系统的计数范围,记做mod或M.如时钟的计量范围是0~11,模=12
计算机也可以看成一个计量系统,它也有一个计量范围,即都存在一个"模".表示n为的计算机的计量范围是0~2<sup>n</sup>-1,模 = 2<sup>n</sup>.
"模"实质上是计量系统产生"溢出"的量,它的值在计量系统上表示不出来,计量系统上只能表示出模的余数.
任何有模的计量系统,均可化减法为加法运算.
例如-8 = 4(mod 12).
其含义为:-8与4对模12是互补的,或者说以12为模时-8的补码为4.
同理,模为12时,-2的补码是10,-5的补码是7.
补码的标准化定义:
{% asset_img chapter1/图1-15.png %}
{% asset_img chapter1/图1-16.png %}
**补码中0的形式唯一**
补码具有如下意义:
+ 计算机中的数据受字长的限制,数据的运算属于有模运算
+ 计算结果直接丢掉进位
+ 可以将减法转化为加法运算
+ 计算机中可只设置加法器,从而可以简化设计,降低成本.
求补码示例:
> x=0.1010	[x]<sub>补</sub>=0.1010
x=-0.1010	[x]<sub>补</sub>=1.0110
x=1010	[x]<sub>补</sub>=01010
x=-1010	[x]<sub>补</sub>=10110

补码的运算:
{% asset_img chapter1/图1-17.png %}
补码运算中**符号位进位直接丢弃**.
补码的加减法比较方便,得到了广泛的应用,目前计算机中广泛采用补码表示,少数机器采用原码进行存储和传输,计算时用补码表示.
机器码的求法对比:
{% asset_img chapter1/图1-18.png %}
当真值为正数时,原码、反码和补码都相同,只有真值为负数时,它们才各不相同.
{% asset_img chapter1/图1-19.png %}

1.4 几种常见的编码
------
下面是几种常见的编码:
+ 十进制数的二进制编码(BCD码) BCD-Binary Coded Decimal
+ 可靠性编码
+ 字符编码

下面一一对其进行介绍.

### 1.4.1 BCD码
**BCD码**主要有如下三种:**8421码**、**2421码**和**余3码**.
8421码与2421码是**有权码**,其各位的权值即为8 4 2 1和2 4 2 1.余3码为**无权码**,其值为在8421码的基础上加3.
如下图所示:
{% asset_img chapter1/图1-20.png %}
这几个编码都是**四位二进制数表示一位十进制数**.
下图为十进制数串在机器中的表示:
{% asset_img chapter1/图1-21.png %}

### 1.4.2 可靠性编码
**可靠性编码**的目的是减少或者发现代码在形成和传送过程中可能发生的错误.下面介绍两种可靠性编码:**奇偶校验码**和**格雷码**
奇偶校验如下:
{% asset_img chapter1/图1-22.png %}
{% asset_img chapter1/图1-23.png %}
上图中的圆圈中一个加号为异或的符号.若有偶数个1,则结果为0,否则为1.
示例如下:
{% asset_img chapter1/图1-24.png %}
奇偶校验的特点:
+ 一种常见的简单校验,只需要1位校验码
+ 只具有发现错误的能力,不具备对错误定位和纠正错误的能力.
+ 只具有发现一串二进制代码中,同时出现奇数个代码出错的能力.
+ 如果同时发生偶数个代码出错,奇偶校验失效.

**格雷码**特点:任意两个相邻的数,其格雷码仅有一位不同.
二进制数转换为格雷码的方法如下:
{% asset_img chapter1/图1-25.png %}
最左侧的第一位不变,后面各位为二进制码两位依次进行异或运算的结果.
示例如下:
{% asset_img chapter1/图1-26.png %}
{% asset_img chapter1/图1-27.png %}

### 1.4.3 字符编码
**字符编码**:ASCII码.

第二章 逻辑代数基础
======
2.1 逻辑代数的基本概念
------
### 2.1.1 逻辑代数公理
**定义**：逻辑代数L是一个封闭的代数系统，由一个逻辑变量集K，常量0和1,以及“或”、“与”、“非”三种基本运算组成。记为：
{% asset_img chapter2/图2-1.png %}

下面介绍一下逻辑代数的5大公理。
**公理1**：交换律
{% asset_img chapter2/图2-2.png %}

**公理2**：结合律
{% asset_img chapter2/图2-3.png %}

**公理3**：分配律
{% asset_img chapter2/图2-4.png %}

**公理4**：0-1律
{% asset_img chapter2/图2-5.png %}

**公理5**：互补律
{% asset_img chapter2/图2-6.png %}

### 2.1.2 逻辑变量及基本运算
**逻辑变量**：用字母表示其值可以变化的量。
逻辑变量的取值只能为**0**或**1**，逻辑值**0**和**1**无大小、正负之分。

逻辑代数的基本运算如下：
+ **或**运算
+ **与**运算
+ **非**运算

下面对其一一进行介绍。
**“或”逻辑**：决定某一事件是否发生的多个条件中，只要有**一个或一个以上条件**成立，事件便可发生。
{% asset_img chapter2/图2-7.png %}
逻辑代数中，**“或”逻辑**用**“或”运算**描述。
{% asset_img chapter2/图2-8.png %}
实现“或”运算关系的逻辑电路称为“**或”门**。
{% asset_img chapter2/图2-9.png %}

**“与”逻辑**：决定某一事件是否发生的多个条件必须**同时具备**，事件才能发生。
{% asset_img chapter2/图2-10.png %}
逻辑代数中，**“与”逻辑**用**“与”运算**描述。
{% asset_img chapter2/图2-11.png %}
实现“与”运算关系的逻辑电路称为“**与”门**。
{% asset_img chapter2/图2-12.png %}

**“非”逻辑**：某一事件的发生取决于**条件的否定**，即事件与事件发生的条件之间构成矛盾。
{% asset_img chapter2/图2-13.png %}
逻辑代数中，**“非”逻辑**用**“非”运算**描述。
{% asset_img chapter2/图2-14.png %}
实现“非”运算关系的逻辑电路称为“**非”门**。
{% asset_img chapter2/图2-15.png %}

### 2.1.3 逻辑函数
**逻辑函数**：随自变量而变化的因变量。
与普通代数中函数的概念相比，逻辑函数具有如下特点：
+ 逻辑函数和逻辑变量一样，取值只有0和1两种可能。
+ 函数和变量之间的关系由“或”、“与“、”非”三种基本运算决定。

此外，逻辑函数还有数字系统研究的角度的定义。
{% asset_img chapter2/图2-16.png %}
设某一逻辑电路的输入逻辑变量为$A_1, A_2, \ldots, A_n$，输出逻辑变量为$F$。
如果当$A_1, A_2, \ldots, A_n$的值确定下来，$F$的值就唯一的确定下来，则$F$被称为$A_1, A_2, \ldots, A_n$的**逻辑函数**。记为：
$$F = f(A_1, A_2, \ldots, A_n)$$

我们知道，逻辑电路的输出取决于**逻辑变量的取值**和**电路本身的结构**，而电路本身的结构又取决于三种基本运算的组合。
因此对于电路的逻辑功能描述，我们可由相应的**逻辑函数**进行完全描述。对电路的分析，也可以借助抽象的代数表达式。

逻辑函数的**相等**的定义如下。
设有两个**相同变量**的逻辑函数：
$$F_1 = f_1(A_1, A_2, \ldots, A_n)$$
$$F_2= f_2(A_1, A_2, \ldots, A_n)$$
若对应于逻辑变量$A_1, A_2, \ldots, A_n$的**任何一组**取值，$F_1$和$F_2$的值**都**相同，则称函数$F_1$和$F_2$相等，记做：
$$F_1 = F_2$$

判断函数相等的方法有以下两种：
+ 真值表法：若两函数的真值表相同，则两函数相等。
+ 代数法：若两函数能化为同一形式，则两函数相等。

### 2.1.4 逻辑函数的表示法
逻辑函数的表示方法共有以下3种：
+ 逻辑表达式
+ 真值表
+ 卡诺图

下面对其一一进行介绍。
**逻辑表达式**是由逻辑变量和“或”、“与”、“非”3种运算符以及括号所构成。
示例如下：
{% asset_img chapter2/图2-17.png %}
逻辑表达式可进行如下的简写：
+ “非”运算符下可不加括号
+ “与”运算符一般可省略
+ 在一个表达式中如果既有“与”运算又有“或”运算，则按**先“与”后“或”**的规则进行运算，可省去括号
+ 运算优先法则，可利用该规律去掉括号
{% asset_img chapter2/图2-18.png %}
+ 与运算和或运算均满足结合律，可利用该规律调整括号

**真值表**：依次列出一个逻辑函数的所有输入变量取值组合及其相应函数值的表格。
一个**n个变量**的逻辑函数，其真值表有**2<sup>n</sup>行**。因为n个逻辑变量一共有2<sup>n</sup>种可能的取值组合。
示例如下：
{% asset_img chapter2/图2-19.png %}

**卡诺图**：由表示逻辑变量所有取值组合的小方格所构成的平面图。它可以图形化的描述逻辑函数，常用于逻辑函数化简。
这一块后面讲逻辑函数化简的时候再详细说，这里就不详细介绍了。

2.2 逻辑代数的基本定理和规则
------
### 2.2.1 逻辑代数的基本定理
下面介绍一下逻辑代数的8大定理及其证明。
{% asset_img chapter2/图2-20.png %}
{% asset_img chapter2/图2-21.png %}
{% asset_img chapter2/图2-22.png %}
{% asset_img chapter2/图2-23.png %}
{% asset_img chapter2/图2-24.png %}
{% asset_img chapter2/图2-25.png %}
{% asset_img chapter2/图2-26.png %}
{% asset_img chapter2/图2-27.png %}
{% asset_img chapter2/图2-28.png %}
{% asset_img chapter2/图2-29.png %}

### 2.2.2 逻辑代数的规则
逻辑代数中有以下3个重要规则：
+ **代入规则**
+ **反演规则**
+ **对偶规则**

下面一一对其进行介绍：
**代入规则**：任何一个含有变量$A$的逻辑等式，如果将所有出现$A$的位置都代之以同一个逻辑函数$F$，则等式仍然成立。
例如：
{% asset_img chapter2/图2-30.png %}
该规则的正确性是显而易见的，因为**任何逻辑函数都和逻辑变量一样，只有0和1两种可能的取值**。
利用代入规则可以将逻辑代数公理、定理中的变量用任意函数代替，从而推导出更多的等式。
不过有一点一定要注意，**等式中所有出现同一变量的地方均应以同一函数代替！**

**反演规则**：
{% asset_img chapter2/图2-31.png %}
需要注意的是，一定要**保持原函数中运算符号的优先顺序不变！**。必要时可以加上括号。
示例如下：
{% asset_img chapter2/图2-32.png %}
可以看到，在原函数中$D\overline{E}$最先进行运算，因此在反函数中也应是$\overline{D} + E$先进行运算，其他运算顺序同理。
我感觉反函数就是对原函数进行取“非”运算，只不过换了个说法。不过网上也没查到这方面的资料，先这样理解吧。

**对偶式**：
{% asset_img chapter2/图2-33.png %}
示例：
{% asset_img chapter2/图2-34.png %}

**注意**：如果$F$的对偶式是$F'$，则$F'$的对偶式就是$F$，即
$$(F')' = F$$
也就是说**$F$和$F'$互为对偶式**。
若**$F' = F$**，则该函数被称为**自对偶函数**。
在求对偶式的过程中，仍应**保持原函数的运算顺序不变**。

**对偶规则**：
{% asset_img chapter2/图2-35.png %}
利用对偶规则可以使定理、公式的证明减少一半。

### 2.2.3 复合逻辑
**复合逻辑**由3种基本运算构成的复合运算来描述，相应的逻辑门则称为**复合门**。
常见的复合逻辑有以下四种：
+ “与非”逻辑
+ “或非”逻辑
+ “与或非”逻辑
+ “异或”逻辑
+ “同或”逻辑

下面对其一一进行介绍。
**“与非”逻辑**是由“与”、“非”两种逻辑复合形成的，可用逻辑函数表示为
$$F = \overline{A \cdot B \cdot C \cdots}$$
其逻辑功能为：
+ 只要变量$A$、$B$、$C$、$\cdots$中**有一个为0**，则**函数$F$为1**
+ 仅当变量$A$、$B$、$C$、$\cdots$**全部为1**时，**函数$F$为0**

**“与非”门**：实现“与非”运算功能的逻辑电路称为“与非”门。
{% asset_img chapter2/图2-36.png %}
{% asset_img chapter2/图2-37.png %}

**“或非”逻辑**是由“或”、“非”两种逻辑复合形成的，可用逻辑函数表示为
$$F = \overline{A + B + C \cdots}$$
其逻辑功能为：
+ 只要变量$A$、$B$、$C$、$\cdots$中**有一个为1**，则**函数$F$为0**
+ 仅当变量$A$、$B$、$C$、$\cdots$**全部为0**时，**函数$F$为1**

**“或非”门**：实现“或非”运算功能的逻辑电路称为“或非”门。
{% asset_img chapter2/图2-38.png %}
{% asset_img chapter2/图2-39.png %}

**“与或非”逻辑**是由“与”、“或”、“非”三种逻辑复合形成的，可用逻辑函数表示为
$$F = \overline{AB + BC + CD \cdots}$$
其逻辑功能为：
+ 仅当每一个“与项”均为0时，才能使$F$为1,否则$F$为0

**“与或非”门**：实现“与或非”运算功能的逻辑电路称为“与或非”门。
{% asset_img chapter2/图2-40.png %}
{% asset_img chapter2/图2-41.png %}

**异或逻辑**可用逻辑函数表示为
$$F = A \oplus B = \overline{A}B + A\overline{B}$$
其逻辑功能为：
+ 变量$A$、$B$**取值相同**，$F$为**0**
+ 变量$A$、$B$**取值相异**，$F$为**1**

**“异或”门**：实现“异或”运算功能的逻辑电路称为“异或”门。
{% asset_img chapter2/图2-42.png %}
异或逻辑具有以下性质：
{% asset_img chapter2/图2-43.png %}
**注意**：
异或运算的多个变量中，若有**奇数个变量的值为1**，则运算结果为**1**；若有**偶数个变量的值为1**，则运算结果为**0**。
奇偶校验码就是应用的此条性质。

“同或逻辑”可用逻辑函数表示为
$$F = A \odot B = \overline{A} \cdot \overline{B} + AB$$
其逻辑功能为：
+ 变量$A$、$B$**取值相同**，$F$为**1**
+ 变量$A$、$B$**取值相异**，$F$为**0**

**“同或”门**：实现“同或”运算功能的逻辑电路称为“同或”门。
{% asset_img chapter2/图2-44.png %}
**注意**：
在进行“同或”运算的多个变量中，若有**奇数个变量的值为0**，则运算结果为**0**；若有**偶数个变量的值为0**，则运算结果为**1**。
**“同或”**实际上是**“异或”之非**，所以实际应用中通常用“异或”门加“非”门实现“同或”运算。
“同或”逻辑和“异或”逻辑**互为相反，又互为对偶**。

2.3 逻辑表达式的形式与转换
------
### 2.3.1 逻辑表达式的基本形式
任何一个逻辑函数，其表达式的形式都不是唯一的。
逻辑函数有以下两种**基本形式**：
+ “与-或”表达式
+ “或-与”表达式

下面对其一一进行介绍。
**“与-或”表达式**：
{% asset_img chapter2/图2-45.png %}

**“或-与”表达式**：
{% asset_img chapter2/图2-46.png %}

逻辑表达式可以被表示成任意的混合形式，无论什么形式都可以变换成两种基本形式。
举例说明：
{% asset_img chapter2/图2-47.png %}
{% asset_img chapter2/图2-48.png %}
但是两种基本形式都不是唯一的，为了在逻辑问题中的研究中使逻辑函数能和唯一的表达式对应，引入了逻辑函数表达式的**标准形式**。

### 2.3.2 逻辑表达式的标准形式
**标准形式**使逻辑函数（功能）和唯一的逻辑表达式对应，其建立在**最小项**、**最大项**概念的基础上。
因此，我们先来介绍一下最小项与最大项的概念。

**最小项**定义：
+ 具有n个变量的函数的“与项”**包含全部n个变量**
+ 每个变量都以原变量或反变量形式**出现一次，且仅出现一次**
+ 该**“与项”**被称为**“最小项”**，有时又称为“标准与项”

**n个变量可以构成2<sup>n</sup>个最小项**。
示例：
{% asset_img chapter2/图2-49.png %}
为了简写，我们通常用**$m_i$**来表示最小项。
**下标i的取值规则**：按照变量顺序将最小项中的**原变量用1表示**，**反变量用0表示**，由此可得一个二进制数，与该二进制数对应的十进制数即下标i的值。
示例：
{% asset_img chapter2/图2-50.png %}
再举一个用最小项表示函数的例子：
{% asset_img chapter2/图2-51.png %}
注意最后一步的表示方法。

下面介绍一下最小项的性质。
**性质1**：任意一个最小项，其相应变量**有且仅有一种**取值使这个最小项的值为**1**。最小项不同，使其值为1的变量取值也不同，任何一种变量取值都不可能使两个不同最小项同时为1。
该性质的正确性也是显而易见的，因为不同的最小项中都存在**互补变量**，不可能存在一种取值使不同的最小项同时为1。
实际上，在由n个变量构成的任意“与项”中，最小项是使其值为1的变量组合数最少的一种“与项”，这也是最小项名字的由来。

**性质2**：相同变量构成的两个**不同**最小项**相“与”为0**。
由性质1可知，任何一种变量取值都不可能使两个不同最小项同时为1，故其相“与”为0。即
$$m_i \cdot m_j = 0 \quad (i \ne j)$$

**性质3**：n个变量的**全部**最小项**相“或”为1**。
通常借用数学中的累加符号“$\sum$”，将其记为：
$$\sum_{i = 0}^{2^n - 1} m_i = 1$$

**性质4**：n个变量构成的最小项有**n**个**相邻最小项**。
**相邻最小项**：除**一个变量互为相反**外，**其余部分均相同**的最小项。
示例：
{% asset_img chapter2/图2-52.png %}

**最大项**定义：
+ 如果一个具有n个变量的函数的“或项”**包含全部n个变量**
+ 每个变量都以原变量或反变量形式**出现一次，且仅出现一次**
+ 该**“或项”**被称为**“最大项”**，有时又称为“标准或项”

**n个变量可以构成2<sup>n</sup>个最大项**。
示例：
{% asset_img chapter2/图2-53.png %}
为了简写，我们通常用**$M_i$**来表示最小项。
**下标i的取值规则**：按照变量顺序将最大项中的**原变量用0表示**，**反变量用1表示**，由此可得一个二进制数，与该二进制数对应的十进制数即下标i的值。
**注意这里的下标i中0和1的取值与最小项的是相反的！**
示例：
{% asset_img chapter2/图2-54.png %}
再举一个用最大项表示函数的例子：
{% asset_img chapter2/图2-55.png %}
注意最后一步的表示方法。

下面介绍一下最大项的性质。
**性质1**：任意一个最大项，其相应变量**有且只有仅有一种**取值使这个最大项的值为**0**，最大项不同，使其值为0的变量取值不同。
在由n个变量构成的任意“或项”中，最大项是使其值为1的变量取值组合数最多的一种“或项”，这也是最大项名字的由来。

**性质2**：相同变量构成的两个**不同**最大项**相“或”为1**。
因为任何一种变量取值都不可能使两个不同最大项同时为0，故相“或”为1，即
$$M_i + M_j = 1 \quad (i \ne j)$$

**性质3**：n个变量的全部最大项相“与”为0。
通常借用数学中的累乘符号“$\prod$”，将其记为：
$$\prod_{i = 0}^{2^n - 1} M_i = 0$$

**性质4**：n个变量构成的最大项有**n**个**相邻最大项**。
**相邻最大项**：除**一个变量互为相反**外，**其余部分均相同**的最大项。
示例：
{% asset_img chapter2/图2-56.png %}

在同一问题中，**下标相同**的最小项和最大项**互为反函数**，相同变量构成的最小项$m_i$和最大项$M_i$之间存在**互补关系**。即
$$\overline{m_i} = M_i \quad 或 \quad \overline{M_i} = m_i$$
示例：
{% asset_img chapter2/图2-57.png %}

逻辑表达式的标准形式有以下两种：
+ **标准“与-或”表达式**：由若干个**最小项相“或”**构成的逻辑表达式，也称**最小项表达式**。
+ **标准“或-与”表达式**：由若干个**最大项相“与”**构成的逻辑表达式，也称**最大项表达式**。
有了这两个标准表达式之后，我们就可以把任何一个表达式变为这两个标准表达式之一，而这两个标准表达式的形式是**唯一的**。
示例：
{% asset_img chapter2/图2-58.png %}

### 2.3.3 逻辑表达式的转换
这一节我们要研究如何将逻辑函数的表达式转换为标准形式。
转换方法主要有以下两种：
+ **代数转换法**：利用逻辑代数的公理、定理和规则进行逻辑变换，将函数表达式从一种形式变换为另一种形式。
+ **真值表转换法**：利用逻辑函数表达式和真值表之间的**一一对应关系**，将函数表达式从一种形式变换为另一种形式。

下面依次对其进行介绍。
**代数转换法**：
求一个函数的**标准“与-或”表达式**：
{% asset_img chapter2/图2-59.png %}
示例：
{% asset_img chapter2/图2-60.png %}
{% asset_img chapter2/图2-61.png %}

求一个函数的**标准“或-与”表达式**：
{% asset_img chapter2/图2-62.png %}
示例：
{% asset_img chapter2/图2-63.png %}
{% asset_img chapter2/图2-64.png %}

**真值表转换法**：
求一个函数的**标准“与-或”表达式**：
{% asset_img chapter2/图2-65.png %}
示例：
{% asset_img chapter2/图2-66.png %}
{% asset_img chapter2/图2-67.png %}
求最小项表达式时，**若真值表中的值为1，则对应原变量，否则对应反变量**。

求一个函数的**标准“或-与”表达式**：
{% asset_img chapter2/图2-68.png %}
示例：
{% asset_img chapter2/图2-69.png %}
{% asset_img chapter2/图2-70.png %}
求最大项表达式时，**若真值表中的值为0，则对应原变量，否则对应反变量**。
其实从上面的这些例子中可以看出来，不管是用真值表求最大项表达式或最小项表达式时，只要真值表是按顺序写的，**标准式中项的下标都对应其在真值表中的位置（从0开始）**。

函数的真值表与函数的两种标准形式之间存在一一对应的关系，而任何一个逻辑函数的真值表都是唯一的。
由此可见：**任何一个逻辑函数的两种标准形式也是唯一的**。
逻辑函数表达式的唯一性为分析和研究逻辑电路问题带来了很大的方便。

2.4 逻辑函数代数化简法
------
为什么要化简？
实现某一逻辑功能的逻辑电路的复杂性与描述该功能的逻辑表达式的复杂性直接相关。一般来说，逻辑函数表达式越简单，设计出来的相应逻辑电路也就越简单。为了降低系统成本、减小复杂度、提高可靠性，必须对逻辑函数进行化简。
常用的化简方法有以下几种：
+ 代数化简法
+ 卡诺图化简法
+ 列表化简法

下面先介绍代数化简法。
**代数化简法**是运用逻辑代数的公理、定理和规则对逻辑函数进行化简。没有固定的规则可以遵循。关键是对逻辑代数中公理、定理和规则的熟练掌握及灵活运用。

### 2.4.1“与-或”表达式的化简
什么是最简的“与-或”表达式呢？
+ 条件1：表达式中的**“与”项个数最少**
+ 条件2：每个“与”项中的**变量个数最少**

满足上述两个条件，相应逻辑电路中所需门的数量以及门的输入端个数均为最少，电路最经济。

常用的化简方法：
{% asset_img chapter2/图2-71.png %}
{% asset_img chapter2/图2-72.png %}
示例;
{% asset_img chapter2/图2-73.png %}
实际应用中遇到的逻辑函数往往比较复杂，化简时应灵活使用所学的公理、定理及规则，综合运用各种方法。

### 2.4.2“或-与”表达式的化简
什么是最简的“或-与”表达式呢？
+ 条件1：表达式中的**“或”项个数最少**
+ 条件2：每个“或”项中的**变量个数最少**

可直接运用公理、定理中的“或-与”形式，综合运用前面介绍“与-或”表达式化简时提出的各种方法进行化简。
示例：
{% asset_img chapter2/图2-74.png %}

此外，还可以利用**两次对偶法**：
{% asset_img chapter2/图2-75.png %}
示例：
{% asset_img chapter2/图2-76.png %}

代数化简法的优点：
+ 不受变量数目的约束
+ 当对公式、定理和规则十分熟练时，化简比较方便

缺点：
+ 没有一定的规律和步骤
+ 技巧性很强
+ **难以判断化简结果是否最简**

2.5 逻辑函数卡诺图化简法
------
### 2.5.1 卡诺图的组成和性质
卡诺图是一种图形化简法，方法简单、直观、容易掌握，在逻辑设计中得到广泛应用。
**卡诺图**：一种平面方格图，每个小方格代表一个**最小项**，又称为**“最小项方格图”**。
卡诺图可以看成是真值表图形化的结果：
+ n个变量的**真值表**是用2<sup>n</sup>行给出变量的2<sup>n</sup>种取值，**每行取值与每一个最小项对应**。
+ n个变量的**卡诺图**是用二维图形中2<sup>n</sup>个小方格的坐标值给出变量的2<sup>n</sup>种取值，**每个小方格与一个最小项对应**。

2变量卡诺图：
{% asset_img chapter2/图2-77.png %}

3变量卡诺图：
{% asset_img chapter2/图2-78.png %}
可以看到，AB中**11是排在10前面的**，为什么要这么做呢？
这样做是为了保证能清楚的反映**最小项的相邻关系**。我们知道，相邻最小项的特点是它里面的变量有一个是互反的，而这种排列方式恰恰让相邻、相对的小方格**只有一个变量不同**，能够反映出最小项的相邻关系。

4变量卡诺图：
{% asset_img chapter2/图2-79.png %}
同上，AB和CD的取值11也是排在10前面。

5变量卡诺图：
{% asset_img chapter2/图2-80.png %}
5变量卡诺图和3变量卡诺图都是长条形的，为什么5变量卡诺图需要拆开，而3变量卡诺图不用呢？
这个问题我在网上也没有找到答案，在这里说说我自己的理解吧。
根据相邻最小项的性质，5变量最小项有5个相邻最小项，只有将5变量卡诺图拆开，才能反映出最小项的所有相邻关系（有一个是相重相邻）。而3变量最小项只有3个相邻最小项，直接画出卡诺图就可以体现出其最小项的所有相邻关系，自然不需要拆开了。

**卡诺图特点**：
+ **n**个变量的卡诺图由**2<sup>n</sup>**小方格构成
+ 几何图形上处在**相邻、相对、相重**位置的小方格代表的最小项为**相邻最小项**
+ 卡诺图中最小项的排列方案不是唯一的，教材中介绍的只是一种排列方案。

注意：**任何一种方案都应保证能清楚的反映最小项的相邻关系！**

下面举几个例子来说明卡诺图的特点。
{% asset_img chapter2/图2-81.png %}
关于相对相邻，可以看成将平面的卡诺图横着或竖着卷成一个筒后的相邻。
{% asset_img chapter2/图2-82.png %}
3与19重叠相邻。

### 2.5.2 逻辑函数在卡诺图上的表示
**标准“与-或”表达式**在卡诺图上的表示：在卡诺图上找出和表达式中对应的小方格填上1，其余小方格填上0。
**一般“与-或”表达式**需要先化为**标准“与-或”表达式**，再用卡诺图表示。
示例：
{% asset_img chapter2/图2-83.png %}

对于一般的“与-或”表达式，还可根据**“与”的公共性（与项变量全为1，与项为1）**和**“或”的叠加性（只要有1项为1，表达式为1）**作出相应卡诺图。这样更加快速。
示例：
{% asset_img chapter2/图2-84.png %}
$AB$对应11那一行，我们令其都取1。$CD$对应11那一列，我们令其都取1。$\overline{A}\overline{B}C$对应0011和0010两个小方格，令其为1。这样卡诺图就作出来了。
说实话我并没有看出来上面的这个做法跟所谓的“与”的公共性和“或”的叠加性有什么关系。
我的做法是这样的，最小项$AB$肯定对应卡诺图中变量$A$的取值为1，变量$B$的取值为1。但是其并没有变量$C$和变量$D$，因此卡诺图中变量$C$和变量$D$取任意值，即1100、1101、1111、1110四个小方格，也就是11那一行，将这一行全部填为1即可。后面的做法与之类似。

### 2.5.3 卡诺图上最小项的合并规律
合并的理论依据是
$$A\overline{B} + AB = A \quad （定理7）$$
两个相邻最小项**有一个变量互反**，可以合并为一项，消去一个变量。
而卡诺图的重要特征正是直观、清晰的反映了**最小项的相邻关系**。
由上面的分析，我们可以得出卡诺图化简逻辑函数的**基本原理**：
+ 将逻辑特征和图形特征结合起来
+ 将卡诺图上表征相邻最小项的相邻小方格**“圈”**在一起进行合并
+ 达到**用一个简单“与”项代替若干最小项**的目的
+ 用来包围那些能由一个简单“与”项代替的若干最小项的圈称为**“卡诺圈”**

下面通过一些例子来看一下**卡诺图上最小项的合并规律**：
{% asset_img chapter2/图2-85.png %}
{% asset_img chapter2/图2-86.png %}
{% asset_img chapter2/图2-87.png %}

**n**变量卡诺图中**最小项的合并规律**：
+ **卡诺圈**中小方格的个数必须是**2<sup>m</sup>**个，m为小于或等于n的整数
+ **卡诺圈**中的**2<sup>m</sup>**个小方格含有**m个不同变量**，**(n - m)个相同变量**。
+ **卡诺圈**中的**2<sup>m</sup>**个小方格对应的最小项可用**(n - m)个变量的“与”项**表示，该“与”项由这些最小项中的**相同变量**构成。
+ 当**m = n**时，**卡诺圈包围了整个卡诺图**，可用**1**表示，即n个变量的全部最小项之和为1。

上面说了一堆，其实简单来说就是**卡诺圈**中小方格的个数是2的几次方，就能消去几个变量。最终形成的“与”项由卡诺圈中的**相同变量**构成。

### 2.5.4 卡诺图化简逻辑函数
在介绍卡诺图化简逻辑函数之前，先介绍几个卡诺图化简中的术语。
**蕴涵项**：“与-或”表达式中，每个**“与”项**被称为该函数的**蕴涵项**。
+ 在函数卡诺图中，任何一个1方格所对应的最小项或者卡诺圈中的2<sup>m</sup>个1方格（即化简后的结果）所对应的“与”项都是函数的**蕴涵项**

**质蕴涵项**：若函数的一个蕴涵项**不是**该函数中其他蕴涵项的**子集**，则此蕴涵项称为**质蕴涵项**，简称为**质项**。
+ 在函数卡诺图中，按照最小项合并规律，如果某个卡诺圈**不可能被其他更大的卡诺圈包含**，该卡诺圈所对应的“与”项为**质蕴涵项**。

**必要质蕴涵项**：若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为**必要质蕴涵项**，简称为**必要质项**。
+ 在函数卡诺图中，若某个卡诺圈**包含了不可能被其他任何卡诺圈包含的1方格**，该卡诺圈所对应的“与”项为**必要质蕴涵项**。

求逻辑函数最简“与-或”表达式的一般步骤：
{% asset_img chapter2/图2-88.png %}
示例：
{% asset_img chapter2/图2-89.png %}
其中用“\*”号标记的为必要质蕴涵项。
从上例中我们可以看出，一个函数的最简“与-或”表达式不一定是唯一的。并且多个最简形式的复杂程度相同。

卡诺图化简的原则：
+ 在覆盖函数中所有最小项的前提下，卡诺圈的个数应达到最少
+ 在满足合并规律的前提下卡诺圈应达到最大
+ 根据合并的需要，每个最小项可以被多个卡诺圈包围

求逻辑函数最简“或-与”表达式：
{% asset_img chapter2/图2-90.png %}
示例：
{% asset_img chapter2/图2-91.png %}
{% asset_img chapter2/图2-92.png %}

2.6 列表化简法
------
卡诺图化简法缺点：受到变量个数的约束，当变量个数大于6时，画图以及对图形的识别都变得相当复杂。
为了克服这些缺陷，又提出了列表化简法。
**列表化简法**又称为奎恩-麦克拉斯基化简法，是一种系统化简法，简称为Q-M化简法。
通过约定的表格形式，按照一定规则完成化简过程。
通过找出函数$F$的全部质蕴涵项，必要质蕴涵项以及最简质蕴涵项集来求得最简表达式。

步骤如下：
{% asset_img chapter2/图2-93.png %}
示例：
{% asset_img chapter2/图2-94.png %}
{% asset_img chapter2/图2-95.png %}
{% asset_img chapter2/图2-96.png %}
{% asset_img chapter2/图2-97.png %}
{% asset_img chapter2/图2-98.png %}

列表化简法特点：
+ 规律性强，对变量数较多的函数，可经过反复比较、合并，得到最简结果。
+ 计算机处理