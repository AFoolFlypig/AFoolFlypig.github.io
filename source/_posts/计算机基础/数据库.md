---
title: 数据库
date: 2023-07-16 10:42:37
mathjax: true
categories: 计算机基础
tags: 
- 数据库
---
# 1 MySQL中一条查询SQL是如何执行的？

<!--more-->

MySQL中一条查询SQL的大致执行步骤如下：

1. **获取连接**：客户端首先通过MySQL中的连接器获取连接，获取连接时连接器要对客户端做**权限验证**。

   - 数据库中有两种连接：**长连接**和**短连接**。

     - 长连接：连接成功后，如果客户端持续有请求，则一直使用同一个连接。
     - 短连接：每次执行完很少的几次查询就断开连接，下次查询再重新建立一个连接。

     因为建立连接的过程通常比较复杂，为了减少建立连接的动作，应当尽量使用长连接。

   - 由于MySQL在执行过程中临时使用的内存是存储在连接对象里面的，这些资源会在连接断开的是否才释放，所以长时间使用长连接可能会导致内存占用太大，被系统强行杀掉，也就是我们有时候看到的MySQL异常重启。这一问题有以下两种解决办法：

     - 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
     - 如果MySQL版本是5.7或以上版本，可以在每次执行一个比较大的操作后，通过执行`mysql_reset_connection`来重新初始化连接资源。这个过程不需要重连和重新做权限校验，但是会将连接恢复到刚创建完成的状态。

2. **查询缓存**：key是查询语句，value是查询结果，如果在缓存中可以查到这个key，就直接把结果返回给客户端。如果查询不到该key，则继续执行后续流程，执行完成后，将执行结果存入缓存中。

   - 由于查询缓存的**失效非常频繁**，只要对表做一次更新操作，该表上的所有查询缓存都会被清空，所以并不推荐使用查询缓存。除非是很久才更新一次的数据表，比如系统配置表，那这张表上的查询才适合使用查询缓存。
   - MySQL8.0中已将查询缓存删除。

3. **分析器**：分为**词法分析**和**语法分析**，此阶段主要做一些SQL解析和语法校验的操作。一般语法错误的提醒在这一阶段。

4. **优化器**：优化器是在表中有多个索引的时候，决定使用哪个索引；或者在一个语句中有多表关联的时候，决定各个表的连接顺序。**EXPLAIN执行计划在优化器阶段生成**。

5. **执行器**：开始执行的时候，要先判断当期那用户对这个表有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。需要注意的是，这里是对表的权限进行校验，而连接器是验证用户的身份。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，大致执行流程如下：

   1. 调用InnoDB引擎接口取这个表的第一行，判断是否满足`where`子句中的判断条件，如果不满足则跳过，如果满足则将这一行放入结果集中。
   2. 调用引擎接口取下一行，重复相同的判断逻辑，直到这个表的最后一行
   3. 执行器将上述遍历过程中所有满足条件的行组成一个结果集返回给客户端。

到这里，查询SQL就执行完成了，图示如下：

![](数据库/fig1.png)

**参考资料**：

[https://cloud.tencent.com/developer/article/1752777](https://cloud.tencent.com/developer/article/1752777)

# 2 InnoDB与MyISAM的区别？

区别如下：

1. InnoDB支持事务，MyISAM不支持。
2. InnoDB支持外键，MyISAM不支持。
3. InnoDB支持聚集索引和非聚集索引，而MyISAM只支持非聚集索引。聚集索引将数据放到了索引的叶子节点上，通过聚集索引查询数据只需要一次查询。MyISAM的索引与数据是分开存储的，索引保存的是指向数据的指针，因此需要通过该地址再进行一次查询才能获得数据。
4. InnoDB不保存表的具体行数（因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的），执行`select count(*) from table`时需要全表扫描，速度较慢。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要获取该变量的值即可，速度很快。
5. InnoDB最小的锁粒度是行锁，MyISAM最小的锁粒度是表锁。在MyISAM中，执行一条更新语句会锁住整张表，导致其他查询和更新都会被阻塞，并发访问受限。

**补充说明**：

InnoDB的存储方式可以分为共享表空间和多表空间两种。

- 共享表空间：一个数据库中所有的表数据、索引文件全部放在表空间中，表结构保存在.frm文件中。
- 多表空间：每个表都有一个.frm文件和.ibd文件。.frm文件存储表结构，.ibd文件存储数据和索引文件。

而MyISAM中的每个表在磁盘上存储为三个文件，他们以表的名字来命名。.frm文件存储表结构，.MYD文件（MYData）存储数据文件，.MYI文件（MYIndex）存储索引文件。

**参考资料**：

[https://juejin.cn/post/7108605020941058085](https://juejin.cn/post/7108605020941058085)

[https://www.zhihu.com/question/20596402](https://www.zhihu.com/question/20596402)

# 3 为什么MySQL建议使用有序的自增ID作为主键？

MySQL底层是以数据页为单位存储数据的，一个数据页大小默认为16K。如果一个数据页存满了，MySQL就会去申请一个新的数据页来存储数据。

- 如果主键为自增id的话，MySQL在写满一个数据页的时候，直接申请另一个数据页接着写就可以了。
- 如果主键为非自增id，为了确保索引有序，MySQL就需要将每次插入的数据都放到合适的位置上。当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，MySQL就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页中。这就造成了页分裂，这个大量利用数据的过程是会严重影响插入效率的。

**参考资料**：

[https://www.cnblogs.com/kancy/p/13458991.html](https://www.cnblogs.com/kancy/p/13458991.html)

# 4 为什么InnoDB存储引擎中使用B+树作为索引的数据结构，而不是B树？

- B树中每个结点不仅包含了数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个结点（即一个页）能存储的key的数量很小，当存储的数据量很大时会导致B树的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。
- 在B+树中，所有数据记录结点都是按照键值大小顺序存放在同一层的叶子结点上，而非叶子结点上只存在key值信息。这样可以大大加大每个结点存储的key值数量，降低B+树的高度。

**参考资料**：

[https://blog.csdn.net/dl962454/article/details/115800802](https://blog.csdn.net/dl962454/article/details/115800802)

# 5 并发事务带来哪些问题？

在数据库系统中，多个事务并发执行可能会导致以下问题：

- **脏读（Dirty Read）**：一个事务读到另外一个事务未提交的数据。
- **不可重复读（Non-Repeatable Read）**：一个事务中两次读**同一行**数据，可是这两次读到的数据不一样。
- **幻读（Phantom Read）**：一个事务中两次查询，但第二次查询比第一次查询**多了或少了几行数据**。

# 6 MySQL是如何实现ACID的？

## 6.1 ACID特性

ACID是衡量事务的四个特性：

- 原子性（Atomicity）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

## 6.2 原子性

原子性指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库回退到事务前的状态。

InnoDB存储引擎提供了两种事务日志：**redo log（重做日志）**和**undo log（回滚日志）**。

- **redo log用于保证事务持久性**
- **undo log则是事务原子性和隔离性实现的基础**

实现原子性的关键，是当数据回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的就是undo log。当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了`rollback`，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

undo log属于逻辑日志，它记录的是sql执行相关的信息。

> - 逻辑日志：可以简单理解为记录的就是sql语句
> - 物理日志：因为MySQL数据最终是保存在数据页中的，物理日志记录的就是数据页变更

当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。

- 对于每个insert，回滚时会执行delete
- 对于每个delete，回滚时会执行insert
- 对于每个update，回滚时会执行一个相反的undate，把数据改回去

## 6.3 持久性

持久性指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存（Buffer Pool），Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

Buffer Pool的使用大大提高了读写数据的效率，但是也带来了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

于是，redo log被引入来解决这个问题。redo log通常是物理日志，记录的是数据页的物理修改。redo log由两部分组成：

- 内存中的**重做日志缓冲（redo log buffer）**，该部分日志是易失性的。
- **重做日志文件（redo log file）**，该部分日志是持久性的。

当数据修改时，除了修改Buffer Pool中的数据，还会在redo log buffer中进行记录。当事务提交（COMMIT）时，必须先将事务的所有redo log buffer写入到redo log file中进行持久化，才能COMMIT成功（**Force Log at Commit**机制）。如果MySQL宕机，重启时可以读取redo log file中的数据，对数据库进行恢复。这种先持久化日志页，然后再持久化数据页的做法也被称为**Write-Ahead Log（WAL，预先日志持久化）**。

既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘（即刷脏）要快呢？主要有以下两方面的原因：

- 刷脏是随机IO，因为每次修改的数据位置随机；但写redo log是追加操作，属于顺序IO。
- 刷脏是以数据页（Page）为单位的，MySQL默认页大小为16KB，一个数据页上的一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。

## 6.4 隔离性

与原子性、持久性侧重于研究事务本身不同，**隔离性研究的是不同事务之间的相互影响**。隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能相互干扰。

简单起见，我们主要考虑最简单的读操作和写操作（加锁读等特殊读操作会特殊说明），那么隔离性的探讨，主要可以分为两个方面：

- 一个事务写操作对另一个事务写操作的影响（**写写**）：**锁机制保证隔离性**
- 一个事务写操作对另一个事务读操作的影响（**读写**）：**MVCC保证隔离性**

InnoDB中，有以下四种隔离级别：

![](数据库/fig2.png)

### 6.4.1 锁机制

首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。

锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。

按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。

由于这里的重点是MySQL事务的实现原理，因此对锁的介绍到此为止，后续还会有更加详细的专门针对MySQL锁机制的介绍。

### 6.4.2 MVCC

在介绍MVCC之前，先介绍一下当前读与快照读的概念。

- **当前读**：读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。以下操作都是当前读：
  - `select ... lock in share mode`（共享锁）
  - `select ... for update`（排他锁）
  - `update`（排他锁）
  - `insert`（排他锁）
  - `delete`（排他锁）
  - 串行化事务隔离级别
- **快照读**：简单的`select`（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据。由于不加锁，所以是非阻塞读。
  - Read Committed：每次`select`，都生成一个快照读
  - Repeatable Read：开启事务后第一个`select`语句才是快照读的地方
  - Serializable：快照读会退化为当前读

**MVCC**（Multi-Version Concurrency Control，多版本并发控制）是一种并发控制的方法，可以在**发生读写冲突时不用加锁解决**。这个读指的是快照读，而不是当前读。

MVCC的实现原理主要是数据库记录中的**隐藏字段**、**基于undo log的版本链**以及**ReadView**，下面我们对其一一进行介绍。

#### 6.4.2.1 隐藏字段

在MySQL中，表中除了我们创建的字段，InnoDB还会自动的给我们添加三个隐藏字段：

- **DB_TRX_ID**：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID
- **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本，配合undo log使用
- **DB_ROW_ID**：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段

MVCC的实现依赖于前两个隐藏字段。

#### 6.4.2.2 基于undo log的版本链

undo log主要分为两种：

- insert undo log：代表事务在`insert`新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即删除。`insert`操作记录没有历史版本，只对当前事务本身可见，对其他事务不可见，所以insert undo log可以在事务提交后直接删除。
- update undo log：事务在进行`update`或`delete`时产生的undo log，不仅在事务回滚时需要，在快照读时也需要，不能随便删除。

每次对数据库记录进行改动，都会产生新版本的undo log，随着更新次数的增多，多有的版本都会被DB_ROLL_PTR属性连接成一个链表，这个链表被称为**版本链**。版本链的头结点就是当前最新的undo log，链尾是最早的旧undo log。

版本链的示例如下：

![](数据库/fig3.png)

#### 6.4.2.3 ReadView

ReadView（读视图）是快照读执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。ReadView主要用于可见性判断，判断当前事务能够看到哪个版本的数据。

工作流程：将版本链的头结点的事务ID（最新数据事务ID）DB_TRX_ID取出来，与系统当前活跃事务的ID对比进行可见性分析，不可见就通过DB_ROLL_PTR回滚指针去取出undo log中的下一个DB_TRX_ID比较，直到找到最近的满足可见性的DB_TRX_ID，该事务ID所在的旧记录就是当前事务能看到的最新的记录。

ReadView中包含了四个核心字段：

|    **字段**    |                       **含义**                       |
| :------------: | :--------------------------------------------------: |
|     m_ids      |                 当前活跃的事务ID集合                 |
|   min_trx_id   |                    最小活跃事务ID                    |
|   max_trx_id   | 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） |
| creator_trx_id |                ReadView创建者的事务ID                |

ReadView中规定版本链数据的访问规则如下：

|             **条件**              |             **是否可以访问**              |                           **说明**                           |
| :-------------------------------: | :---------------------------------------: | :----------------------------------------------------------: |
|     trx_id == creator_trx_id      |              可以访问该版本               |              说明数据是当前事务更改的，可以访问              |
|        trx_id < min_trx_id        |              可以访问该版本               |                   说明数据已提交，可以访问                   |
|       trx_id >= max_trx_id        |             不可以访问该版本              | 说明该事务是在ReadView生成后开启的，对创建了ReadView的当前事务不可见，不能访问 |
| min_trx_id <= trx_id < max_trx_id | 如果trx_id不在m_ids中，是可以访问该版本的 | trx_id在m_ids中，说明数据已经提交，可以访问；反之，说明数据未提交，不能访问 |

其中，trx_id代表当前undo log版本链对应事务ID。

不同的隔离级别，生成Read View的时机不同：

- READ COMMITTED：在事务中每一次执行快照读时生成ReadView。
- REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。

## 6.5 一致性

一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。保证数据库系统的一致性其实就是保证数据库系统从一个正确的状态到另一个正确的状态。

可以说，一致性是事务追求的最终目标，前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。

## 6.6 总结

下面总结一下ACID特性及其实现原理：

- 原子性：使用undo log，从而达到回滚
- 持久性：使用redo log，从而达到故障后恢复
- 隔离性：使用锁以及MVCC
- 一致性：通过实现上述三个特性来保证数据库的一致性

**参考资料**：

[https://www.cnblogs.com/kismetv/p/10331633.html](https://www.cnblogs.com/kismetv/p/10331633.html)

[https://www.cnblogs.com/mengxinJ/p/14211427.html](https://www.cnblogs.com/mengxinJ/p/14211427.html)

[https://www.cnblogs.com/f-ck-need-u/p/9010872.html](https://www.cnblogs.com/f-ck-need-u/p/9010872.html)

[https://blog.csdn.net/SnailMann/article/details/94724197](https://blog.csdn.net/SnailMann/article/details/94724197)

[https://segmentfault.com/a/1190000017888478](https://segmentfault.com/a/1190000017888478)

# 7 MySQL中的锁机制？

## 7.1 介绍

首先介绍一下MySQL中锁的类型。

按操作分类：

- **读锁（共享锁）**：针对同一份数据，多个读操作可以同时进行，不会相互影响
- **写锁（排他锁）**：当前写操作没有完成前，它会阻断其他写锁和读锁

按粒度分类：

- **表级锁**：表级锁是MySQL中锁定粒度最大的一种锁，表示当前操作对整张表加锁。它实现简单，资源消耗较少，而且不会出现死锁。
- **页级锁**：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多；行级锁冲突少，但速度慢。所以取表级锁和行级锁的折中方案——页级锁，一次锁定相邻的一组记录。页级锁锁定粒度介于表级锁与行级锁之间，会发生死锁。
- **行级锁**：行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大，会发生死锁。

从上到下，锁的粒度逐渐细化，但实现锁的开销逐渐增大。同时，我们要知道，表级锁、页级锁以及行级锁并不是一个具体的锁，仅代表将数据库某个层级上的数据进行锁定。具体怎么去锁这个数据，还要看具体的锁的实现是什么。

不同存储引擎对上述不同粒度的锁的实现如下：

| **存储引擎** | 行级锁 | 表级锁 | 页级锁 |
| :----------: | :----: | :----: | :----: |
|    MyISAM    |        |   √    |        |
|     BDB      |        |   √    |   √    |
|    InnoDB    |   √    |   √    |        |
|    Memory    |        |   √    |        |

InnoDB存储引擎并不支持页级锁，下面我们主要讲解InnoDB存储引擎中的锁。InnoDB中的锁大致可以分类如下：

![](数据库/fig5.png)

## 7.2 InnoDB中的表级锁

InnoDB中的表级锁主要可分为以下两类：

- 表锁
- 意向锁

### 7.2.1 表锁

对于表锁，分为以下两类：

- 表共享读锁（Table Read Lock）
- 表独占写锁（Table Write Lock）

上面这两种锁没什么好说的，就是对整张表加读锁或者写锁。下面主要介绍下意向锁。

### 7.2.2 意向锁

**意向锁（Intention Lock）**是一种不与行锁冲突的表级锁。意向锁的主要目的是展示出某事务已对表中的某行加锁，或者即将对表中的某行加锁。

意向锁的具体实现，可以分为以下两种：

- **意向共享锁（IS）**：事务打算给表中的某些行加行级共享锁（S锁），事务在给某些行加行级共享锁（S锁）之前必须先取得该表的意向共享锁（IS锁）。由`select ... lock in share mode`添加。
- **意向排他锁（IX）**：事务打算给表中的某些行加行级排他锁（X锁），事务在给某些行加行级排他锁（X锁）前必须取得该表的意向排他锁（IX锁）。由`insert`、`update`、`delete`、`select ... for update`添加。

一旦事务提交，其所持有的锁都会自动释放，包括意向共享锁与意向排他锁。

意向锁是一个比较弱的锁，所以**意向锁与意向锁之前互不排斥**。由于意向锁本身就是为了解决行表锁的共存问题，所以意向锁也不会与行锁产生冲突。下表展示了意向锁和表记共享锁、表级排他锁的兼容性。

![](数据库/fig6.png)

有了意向锁，就可以在加表锁时快速判断表中是否有记录被上锁，比如向一个表添加表锁时：

- 没有意向锁，需要遍历整个表判断是否有锁定的记录
- 有了意向锁，首先判断是否存在意向锁，然后判断该意向锁与即将添加的表锁是否兼容即可

## 7.3 InnoDB中的行级锁

InnoDB中的行级锁根据锁的算法实现又可以分为：**记录锁（Record Lock）**、**间隙锁（Gap Lock）**、**临键锁（Next-Key Lock）**以及**插入意向锁（Insert Intention Lock）**。

不同的锁锁定的位置是不同的，比如说记录锁只锁定对应的记录，而间隙锁锁住记录和记录之间的间隙，临键锁则同时锁住记录以及记录之间的间隙。不同锁类型锁定的范围大致如图所示：

![](数据库/fig8.png)

### 7.3.1 记录锁

**记录锁（Record Lock）**就是我们单纯认知的行锁，只锁住一条记录，准确的说是一条索引记录。InnoDB中的记录锁，是依赖索引实现的，其锁住某行数据的本质是**锁住行数据对应在聚集索引中的索引记录**。记录锁在RC、RR隔级别下都支持。

普通的`select`语句，在执行时是不会加锁的。执行`select ... lock in share mode`语句会添加共享锁，执行`insert`、`update`、`delete`、`select ... for update`等语句会添加排他锁。

![](数据库/fig7.png)

以下面两条SQL的执行为例，讲解一下InnoDB对于单行数据的加锁原理：

```sql
update user set age = 10 where id = 49;
update user set age = 10 where name = 'Tom';
```

第一条SQL使用主键进行查询，只需要在`id = 49`这个主键索引（同时也是聚集索引）上加锁。第二条SQL使用二级索引查询，那么首先在`name = 'Tom'`这个索引上加锁，由于二级索引还需要根据主键到聚集索引之上进行回表查询，所以还需要在`id = 49`这个主键索引（聚集索引）上加锁。

也就是说，使用聚集索引时只需要加一把锁，而使用二级索引需要在二级索引和聚集索引上各加一把锁。

另外，由于行锁是加在索引上的，所以如果当使用的SQL语句不走索引的话，那么它就会升级到表锁，最终造成效率低下。

### 7.3.2 间隙锁

**间隙锁（Gap Lock）**，顾名思义，它会封锁索引记录中的间隙，不让其他事务在间隙中插入数据。它锁定的是一个**不包含索引本身的左右开区间范围$(index1, index2)$**。间隙锁作用在RR隔离级别下。

间隙锁是锁定索引记录之间的间隔，或者锁定第一条索引记录之前的范围，又或者锁定最后一条索引记录之后的范围，说白了，间隙锁的目的就是为了**防止其他事务在索引间隙中插入数据**。

间隙锁的一些特点如下：

- **间隙锁是可以共存的**。间隙锁唯一目的是防止其他事务插入间隙，因此一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。
- **间隙锁只发生在事务隔离级别为RR的情况下**。它用于在隔离级别为RR时，**阻止幻读的发生**。

### 7.3.3 临键锁

临键锁（Next-Key Lock）实际上就是记录锁（Record Lock）和间隙锁（Gap Lock）的组合，即锁住了间隙，又锁住了索引本身，组合起来构成了一个左开右闭区间的锁范围。即**临键锁锁的是索引记录本身，以及索引记录之前的间隙$(index1, index2]$**。临键锁作用在RR隔离级别下。

### 7.3.4 插入意向锁

#### 7.3.4.1 介绍

**插入意向锁（Insert Intention Lock）**是在插入一条记录行前，**由`insert`操作产生的一种间隙锁**。该锁用以表示插入意向，当多个事务在**同一区间**（gap）插入**位置不同**的多条数据时，事务之间**不需要互相等待**。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行的排他锁之前，都会先获取$(4,7)$之间的插入意向锁。但是两个事务之间并不会阻塞等待，因为两个数据行并不冲突。插入意向锁作用在RR隔离级别下。

总的来说，插入意向锁有以下特性：

- **插入意向锁是一种特殊的间隙锁**，属于行级锁的一种。
- **插入意向锁之间互不排斥**，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引）不冲突，那么事务之间就不会出现冲突等待。
- **插入意向锁和普通间隙锁互不兼容**，即插入意向锁锁的间隙和普通间隙锁锁的间隙不能有重合，否则会阻塞。

插入意向锁与普通间隙锁之间的不同点如下：

- **普通间隙锁**的目的是为了**防止其他事务对锁间隙的插入行为**。作用之一就是避免了在RR级别下幻读行为。
- 而**插入意向锁**的目的是替换插入行为产生的普通间隙锁（因为普通间隙锁不支持多事务对同一间隙进行插入），其中最大的作用是**允许多事务在锁间隙内并发写入**。

插入意向锁的兼容性如下：

|      标题      | 插入意向锁 | Gap锁  |
| :------------: | :--------: | :----: |
| **插入意向锁** |    兼容    | 不兼容 |
|   **Gap锁**    |   不兼容   |  兼容  |

#### 7.3.4.2 为什么要用插入意向锁替代普通间隙锁？

在回答上面这一问题之前，我们要先明白事务的插入行为会造成什么。

我们知道，当某个事务插入一个新行时，肯定要获取该行的排他记录锁。看起来好像没毛病，但问题是，**在新行没有生成前，怎么获取该新行的排他记录锁？**很明显是不能的。所以一个插入行为，在获取新行的排他记录锁之前，我们需要先获取新行所在的索引区间的锁，即间隙锁。

也就是说，一个插入单行数据的行为，必须先获得一个粗粒度的锁，才能安全的保证新行生成前，没有其他事务插入同样的新行（避免冲突）。间隙锁在这里的作用就是阻塞企图在该索引间隙中插入数据的其他事务。

基于上述分析，我们知道**一个插入行为必须要先获得粗粒度的间隙锁，才能保证生成新行，再获取细粒度的该行的排他记录锁**。但是普通的间隙锁一旦锁住了某个间隙，这个间隙就不再允许其他事务插入数据了。其他事务需要等待当前事务释放该区间的间隙锁后，才能插入数据。而插入意向锁就不一样了，插入意向锁虽然跟间隙锁一样，一次锁的是一个区间，但是它可以允许多个事务在这个区间内执行不同数据的插入，互不干扰，大大提高了事务插入操作的并发性能。

#### 7.3.4.3 实验

关于插入意向锁，我做了一些小实验。

在RR隔离级别下，有如下数据库表：

|  id  | name | age  |
| :--: | :--: | :--: |
|  1   | Mike |  10  |
|  2   | Jone |  20  |
|  3   | Tony |  30  |

表名为users，在id上建立主键索引，在age上建立常规索引。

首先事务A插入了一行数据，并且没有`commit`：

```sql
insert into users values(4, 'Tom', 15);
```

此时事务B执行下面两句查询都会阻塞住：

```sql
select * from users where id >= 3 lock in share mode;
select * from users where age >= 10 and age <= 20 lock in share mode;
```

这说明**插入意向锁作用在了所有索引的相关间隙上**，也就是说，这个表中的每个索引，都会在包含插入的数据的这一段间隙上添加插入意向锁。在这一示例中，id在$(3,+\infty)$这一间隙以及age在$(10, 20)$这一间隙都被添加了插入意向锁。而插入意向锁与间隙锁之间是不兼容的，所以会出现上面的阻塞。

另外，插入意向锁与其他锁一样，都是在事务提交时释放。

**参考资料**：

[https://www.cnblogs.com/jojop/p/13982679.html](https://www.cnblogs.com/jojop/p/13982679.html)

[https://blog.csdn.net/cmm0401/article/details/116013750](https://blog.csdn.net/cmm0401/article/details/116013750)

[https://juejin.cn/post/6844903666856493064](https://juejin.cn/post/6844903666856493064)

[https://blog.csdn.net/SnailMann/article/details/88353099](https://blog.csdn.net/SnailMann/article/details/88353099)

# 8 数据库的三大范式

- 1NF：符合1NF的关系中的每个属性都不可再分
- 2NF：2NF在1NF的基础上，消除了非主属性对于码的部分函数依赖
- 3NF：3NF在2NF的基础上，消除了非主属性对于码的传递函数依赖

上面说的码指的是候选码。

**参考资料**：

[https://zhuanlan.zhihu.com/p/20028672](https://zhuanlan.zhihu.com/p/20028672)

# 9 B树和B+树

## 9.1 B树

B树，又称多路平衡搜索树，B树中所有结点的孩子结点数的最大值称为B树的阶，通常用$m$表示。一颗$m$阶的B树或为空树，或为满足如下特性的$m$叉树：

- **具有$k$个子结点的的非叶结点包含$k-1$个关键字**（可以存有的键值对）
- 树中每个结点至多有$m$棵子树（即至多含有$m-1$个关键字）
- 如果根节点不是叶子结点，则至少有两颗子树
- 除了根节点外的所有非叶节点至少有$\lceil m/2 \rceil$棵子树（即至少含有$\lceil m/2 \rceil - 1$个关键字）
- **每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它**。
- 所有叶子结点的高度一致。

$3$阶B树的示例如下：

![](数据库/fig9.png)

## 9.2 B+树

B+树是B树的改进版，二者最大的区别在于：

- B树的数据可以存储在内部结点（非叶子结点）中，也可以存储在叶子结点中。
- 而在B+树中，内部结点上仅存放数据的索引，数据只存储在叶子结点上。并且每个叶子结点都存有相邻叶子结点的指针，形成了一个关键字由小到大的单向链表。

B+树有两种实现方式，一种是：

- 具有$k$个子结点的非叶结点包含$k$个关键字。
- 非叶结点的每个索引项仅含有**对应子树的最大（或最小）关键字**和指向该子树的指针。

上述实现也就是我们在教科书上学到的实现，该实现下的$3$阶B+树如下图：

![](数据库/fig10.jpg)

另外一种实现是：

- 具有$k$个子结点的的非叶结点包含$k-1$个关键字（与B树相同）
- 父结点的每个索引项含有其**右子树的最小关键字**和指向该子树的指针。

上述实现的3阶B+树如下图：

![](数据库/fig11.webp)

**参考资料**：

[B+树详解](https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree)

[面试官问你B树和B+树，就把这篇文章丢给他](https://segmentfault.com/a/1190000020416577)