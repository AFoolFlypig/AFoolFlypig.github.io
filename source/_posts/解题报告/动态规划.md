---
title: 动态规划
date: 2018-03-23 16:52:36
categories: 解题报告
tags: 
- c/c++
- 算法
- 动态规划
---

# 1. 01背包

> 问题描述
　　给定N个物品,每个物品有一个重量W和一个价值V.你有一个能装M重量的背包.问怎么装使得所装价值最大.每个物品只有一个.  
　　<!--more-->
输入格式  
　　输入的第一行包含两个整数n, m，分别表示物品的个数和背包能装重量。  
　　以后N行每行两个数Wi和Vi,表示物品的重量和价值  
输出格式  
　　输出1行，包含一个整数，表示最大价值。  
样例输入  
3 5  
2 3  
3 5  
4 7  
样例输出  
8  
数据规模和约定  
　　1<=N<=200,M<=5000.　　

解题思路:动态规划,面对当前商品有两种可能性：  
第一，包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即f(i,j)=f(i-1,j)；   
第二，还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即f(i,j)=max｛ f(i-1,j)，f(i-1,j-w(i))+v(i) ｝   
其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)但价值增加了v(i)；  
由此可以得出递推关系式：

　　　　1) j<w(i)      V(i,j)=V(i-1,j)

　　　　2) j>=w(i)     V(i,j)=max｛ V(i-1,j)，V(i-1,j-w(i))+v(i) ｝

另外,由于f[0][j]为0,则当i为1时,f[i-1][j]为0,这就是代码17行的意义,而且这样不用初始化f[0][j]为0,提高了效率.
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;
const int maxn = 200 + 10;
const int maxm = 5000 + 10;
int f[maxn][maxm];

int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    int w,v;
    for(int i = 1;i <= n;i++){
        scanf("%d%d",&w,&v);
        for(int j = 0;j <= m;j++){
            f[i][j] = (i == 1 ? 0 : f[i - 1][j]);
            if(j >= w) f[i][j] = max(f[i][j],f[i - 1][j - w] + v);
        }
    }
    printf("%d\n",f[n][m]);
    return 0;
}
```

# 2. 包子凑数
小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

输入
----
第一行包含一个整数N。(1 <= N <= 100)
以下N行每行包含一个整数Ai。(1 <= Ai <= 100)  

输出
----
一个整数代表答案。如果凑不出的数目有无限多个，输出INF。

例如，
输入：
2  
4  
5   

程序应该输出：
6  

再例如，
输入：
2  
4  
6    

程序应该输出：
INF

样例解释：
对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。  
对于样例2，所有奇数都凑不出来，所以有无限多个。  

解题思路:这个题我是真的不会,在看了网上的一些博客之后我才明白.**如果所有数的最大公约数为1,那么不能凑出的数为有限个,否则为无限个**.另外,这个题还是完全背包的一个变形,我虽然看了看完全背包的思路,也理解了,但是这个题仍然不会做,还是得多练啊.
```cpp
#include <iostream>
#include<cstdio>
#include<cstring>

using namespace std;
const int N = 10000;
const int maxn = 110;

int gcd(int a,int b){
    if(b == 0) return a;
    else return gcd(b,a%b);
}

int main(){
    int n,a[maxn];
    scanf("%d",&n);
    for(int i = 0;i < n;i++)
        scanf("%d",&a[i]);
    int g = a[0];
    for(int i = 1;i < n;i++)
        g = gcd(g,a[i]);
    if(g != 1) printf("INF\n");
    else{
        bool b[N];
        memset(b,0,sizeof(b));
        b[0] = true;
        for(int i = 0;i < n;i++){
            for(int j = 0;j + a[i] < N;j++){
                if(b[j]) b[j + a[i]] = true;
        }
    }
    int cnt = 0;
    for(int i = 0;i < N;i++)
        if(!b[i]) cnt++;
    printf("%d\n",cnt);
    }
    return 0;
}
```