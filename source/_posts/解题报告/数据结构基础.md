---
title: 数据结构基础
date: 2018-03-08 22:06:53
categories: 解题报告
tags: 
- 数据结构
- c/c++
---
终于开始这一篇章了，革命尚未成功，同志仍需努力啊。
<!--more-->

1. 破损的键盘（Broken Keyboard，uva11988）
------
解题思路：这个题。。。。。。我真是无语了，刚开始不知道home键和end键是啥玩意，理解错题意了。这个题由于有多组数据的移动，所以要用链表，用数组的话会超时。注意代码32行以及32行与33行的顺序。
```cpp
#include<cstdio>
#include<cstring>

using namespace std;

const int maxn = 100000 + 10;

struct node{
    char data;
    node *next;
};

char s[maxn];

int main(){
    while(scanf("%s",s) == 1){
        node *head,*last,*pos;
        head = new node;
        head->next = NULL;
        last = head;
        pos = head;
        int len = strlen(s);
        for(int i = 0;i < len;i++){
            if(s[i] == '['){pos = head; continue;}
            else if(s[i] == ']'){pos = last; continue;}
            else{
                node *p;
                p = new node;
                p->data = s[i];
                p->next = pos->next;
                pos->next = p;
                if(pos == last) last = p;
                pos = p;
            }
        }
        for(node *p = head->next;p != NULL;p = p->next){
           printf("%c",p->data); 
        }
        printf("\n");
    }
    return 0;
}
```
**有些情况下基于数组的链表比基于指针的数组更简单，也更高效**。

2. 树（Tree，uva548）
------
解题思路：这个题我不会，一点思路没有。我是看了书上的程序之后才理解的这个题的思路。
给出中序序列与后序序列，后序序列最后一个字符即为根节点，而中序序列的根节点则是在中间，两边分别是左子树的结点序列和右子树的结点序列。然后根据左子树的序列长度，又能在后序序列中找到坐子树的根节点。同理，可以找到右子树的根节点。根据这种思路，递归创建二叉树。然后dfs寻找最优解。
这个题写出来之后无法运行，我觉得可能是哪一处的指针出了问题，没想到啊没想到，我找了接近一个小时，最后发现第37行的第四个参数写错了，写成了R2。嘿呀，好气啊。
```cpp
#include<cstdio>
#include<iostream>
#include<sstream>

using namespace std;

struct node{
    int data;
    node *left,*right;
    node(){
        left = NULL;
        right = NULL;
    }
};

const int maxn = 10000 + 10;
int inorder[maxn],postorder[maxn],n;
int best,best_sum;

bool read_list(int *a){
    string line;
    if(!getline(cin,line)) return false;
    n = 0;
    stringstream s(line);
    while(s >> a[n]) n++;
    return n > 0;
}

void build(node *&root,int L1,int R1,int L2,int R2){
    if(R1 >= L1){
        root = new node();
        root->data = postorder[R2];
        int i = L1;
        for(;inorder[i] != root->data;i++) {}
        int cnt = i - L1;
        build(root->left,L1,i - 1,L2,L2 + cnt - 1);
        build(root->right,i + 1,R1,L2 + cnt,R2 - 1);
    }
}

void dfs(node *root,int sum){
    sum += root->data;
    if(root->left == NULL && root->right == NULL){
        if(best_sum > sum || (best_sum == sum && best > root->data)){
            best = root->data;
            best_sum = sum;
        }
    }
    if(root->left != NULL) dfs(root->left,sum);
    if(root->right != NULL) dfs(root->right,sum);
}

int main(){
    while(read_list(inorder)){
        read_list(postorder);
        node *root = NULL;
        build(root,0,n - 1,0,n - 1);
        best_sum = 100000000;
        dfs(root,0);
        cout << best << endl;
    }
    return 0;
}
```

3. 下落的树叶（The Falling Leaves,uva699）
------
解题思路：这个题没有必要建树之后再遍历寻找权和，直接dfs求和就可以了。定义一个sum数组，pos位置处即为根节点那一列的权和，pos-1和pos+1则分别是左子树根节点和右子树根节点那一列的权和。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>

using namespace std;

const int maxn = 200;
int sum[maxn];

void build(int p){
    int v;
    cin >> v;
    if(v == -1) return;
    sum[p] += v;
    build(p - 1);
    build(p + 1);
}

bool init(){
    int v;
    cin >> v;
    if(v == -1) return false;
    memset(sum,0,sizeof(sum));
    int pos = maxn / 2;
    sum[pos] += v;
    build(pos - 1);
    build(pos + 1);
    return true;
}

int main(){
    int Case = 0;
    while(init()){
        printf("Case %d:\n",++Case);
        int p = 0;
        while(sum[p] == 0) p++;
        printf("%d",sum[p++]);
        while(sum[p] > 0) printf(" %d",sum[p++]);
        printf("\n\n");
    }
    return 0;
}
```

4. 油田（Oil Deposits，uva 572）
------
解题思路：这个题就是用dfs求连通块，需要注意的是定义了一个idx数组，存放了联通分量编号，每次访问前检查它是否已有了编号，以防一个格子访问多次。另外，dfs中的那个二重循环是用来找到当前格子相邻的8个格子，并对其进行dfs的。
```cpp
#include<cstdio>
#include<cstring>

using namespace std;

const int maxn = 100 + 5;
char gra[maxn][maxn];
int idx[maxn][maxn],m,n;

void dfs(int x,int y,int id){
    if(x < 0 || x > m || y < 0 || y > n) return;
    if(idx[x][y] > 0 || gra[x][y] != '@') return;
    idx[x][y] = id;
    for(int i = -1;i <= 1;i++)
        for(int j = -1;j <= 1;j++)
            if(i != 0 || j != 0) dfs(i + x,j + y,id);
}

int main(){
    while(scanf("%d%d",&m,&n) == 2 && m){
        for(int i = 0;i < m;i++) scanf("%s",gra[i]);
        memset(idx,0,sizeof(idx));
        int cnt = 0;
        for(int i = 0;i < m;i++)
            for(int j = 0;j < n;j++)
                if(idx[i][j] ==  0 && gra[i][j] == '@')
                    dfs(i,j,++cnt);
        printf("%d\n",cnt);
    }
    return 0;
}
```

5. 学霸的迷宫 
------

问题描述
　　学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。
输入格式
　　第一行两个整数n， m，为迷宫的长宽。
　　接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1,1)的地方，即左上角，迷宫的出口在(n,m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1,1)，(n,m)可以通过。
输出格式
　　第一行一个数为需要的最少步数K。
　　第二行K个字符，每个字符∈{U,D,L,R},分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。
样例输入
Input Sample 1:
3 3
001
100
110

Input Sample 2:
3 3
000
000
000
样例输出
Output Sample 1:
4
RDRD

Output Sample 2:
4
DDRR
数据规模和约定
　　有20%的数据满足：1<=n,m<=10
　　有50%的数据满足：1<=n,m<=50
　　有100%的数据满足：1<=n,m<=500。


解题思路：利用bfs求最短路，不过我没有搞那个字典序，还是过了，很奇怪。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>

using namespace std;

const int maxn = 500 + 10;

struct node{
    int x,y,cnt;
    string s;
    node(){
        x = 0;
        y = 0;
        s = "";
        cnt = 0;
    }
};
int m,n,sta[maxn][maxn],lab[maxn][maxn];
int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};
char dir_id[4] = {'U','D','L','R'};

void bfs(node begin){
    queue<node> que;
    que.push(begin);
    sta[0][0] = 1;
    while(!que.empty()){
        node a;
        a = que.front();
        que.pop();
        if(a.x == n - 1 && a.y == m - 1){
            cout << a.cnt << endl;
            cout << a.s << endl;
            break;
        }
        for(int i = 0;i < 4;i++){
            node b = a;
            b.x += dir[i][0];
            b.y += dir[i][1];
            if(b.x >= 0 && b.x < n && b.y >= 0 && b.y < m && sta[b.x][b.y] == 0 && lab[b.x][b.y] == 0){
                sta[b.x][b.y] = 1;
                b.cnt++;
                b.s += dir_id[i];
                que.push(b);
            }
        }
    }
}

int main(){
    scanf("%d%d",&n,&m);
    memset(sta,0,sizeof(sta));
    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            scanf("%1d",&lab[i][j]);
        }
    }
    node begin;
    bfs(begin);
    return 0;
}
```

6. 巡逻机器人（Patrol Robot，uva1600）
------
解题思路：很明显的BFS最短路，但是这个题跟上一个不一样。如果只是单纯使用二维数组去标记是否已经访问过改点是错误的做法，走到该点的机器人因为有穿越障碍物的步数限制，所以可能有些略绕但是行得通的路就会被二维数组这种标记方式把路给封死，比如下面这个例子，假设BFS机器人的走位是先右后左，并且k = 3，如果采用二维标记则会出错

0 1 1 1 1
0 1 1 1 0

因为在普通BFS中能走的都是通路，如果当前点再去走已经被标记的点必然不是最优，而现在对于机器人而言，又有一个可跨越障碍的步数这个限制，那么走到某一个点当然是机器人还能跨越障碍物的步数越多越好。其实这个题解决的办法就是给再sta（其实这里用vis这个标识符比较好）增加一个维度，表示当前机器人是跨越了多少个障碍物来到这里的这个状态即可。
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>

using namespace std;

const int maxn = 25;
struct node{
    int x,y,s,now_k;
    node(){
        x = y = s = now_k =0;
    }
};
int sta[maxn][maxn][maxn],gra[maxn][maxn];
int m,n,k;
int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};

bool check(node a){
    if(a.x < 0 || a.x >= m || a.y < 0 || a.y >= n)
        return false;
    return true;
}

void bfs(node begin){
    bool flag = true;
    queue<node> q;
    q.push(begin);
    sta[0][0][0] = 1;
    while(!q.empty()){
        node now = q.front();
        q.pop();
        if(now.x == m - 1 && now.y == n - 1){
            printf("%d\n",now.s);
            flag = false;
            break;
        }
        for(int i = 0;i < 4;i ++){
            node next_step = now;
            next_step.x += dir[i][0];
            next_step.y += dir[i][1];
            if(check(next_step)){
                if(gra[next_step.x][next_step.y] == 1) next_step.now_k++;
                else next_step.now_k = 0;
                if(next_step.now_k <= k && sta[next_step.x][next_step.y][next_step.now_k] == 0){
                    next_step.s++;
                    q.push(next_step);
                }
                sta[next_step.x][next_step.y][next_step.now_k] = 1;
            }
        }
    }
    if(flag) printf("-1\n");
}

int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&m,&n,&k);
        memset(sta,0,sizeof(sta));
        for(int i = 0;i < m;i++){
            for(int j = 0;j < n;j++){
                scanf("%d",&gra[i][j]);
            }
        }
        node begin;
        bfs(begin);
    }
    return 0;
}
```

7. 平衡的括号（Parentheses Balance，uva673）
------
解题思路：这个题就是用栈做，挺简单的一个题。**注意空串，不能用cin读字符串，应该用getline，cin读取不了空串**，还有注意数字后的那个回车，应该用getchar()吃掉，否则会被getline读入。
这个题刚开始wa，是我不知道cin无法读入空串，没做处理，这个该错。但是改过来之后还是wa，我找了半个小时，才发现输出错了......我输出的YES和NO，真想啪啪给自己俩大嘴巴子。
```cpp
#include<cstdio>
#include<iostream>
#include<stack>

using namespace std;

int main(){
    int t;
    scanf("%d",&t);
    getchar();
    while(t--){
        stack<char> sta;
        string s;
        getline(cin,s);
        bool flag = true;
        int i;
        for(i = 0;i < s.length();i++){
            if(s[i] == '(' || s[i] == '[')
                sta.push(s[i]);
            else if(s[i] == ')' && !sta.empty() && sta.top() == '('){
                sta.pop();
            }
            else if(s[i] == ']' && !sta.empty() && sta.top() == '['){
                sta.pop();
            }
            else {flag = false; break;}
        }
        if(sta.empty() && flag) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

8. 二叉树重建（Tree Recovery，uva536）
------
解题思路：这个题跟前面的那个题很像，不过这个build函数中的L1,R1是前序序列的起始位置和最后的位置，L2,R2是后序序列的起始位置和最后的位置。
```cpp
#include<cstdio>
#include<string>
#include<iostream>

using namespace std;

struct node{
    node *left,*right;
    char data;
    node(){
        left = NULL;
        right = NULL;
    }
};
string preord,inord;

node* build(int L1,int R1,int L2,int R2,node *root){
    if(L1 > R1) return NULL;
    root = new node();
    root->data = preord[L1];
    int p = L2;
    while(inord[p] != root->data) p++;
    int cnt = p - L2;
    root->left = build(L1 + 1,L1 + cnt,L2,p - 1,root->left);
    root->right = build(L1 + cnt +1,R1,p + 1,R2,root->right);
    return root;
}

void postorder(node *root){
    if(root == NULL) return;
    postorder(root->left);
    postorder(root->right);
    printf("%c",root->data);
}

int main(){
    while(cin >> preord >> inord){
        node *root;
        int n = preord.length();
        root = build(0,n - 1,0,n - 1,root);
        postorder(root);
        printf("\n");
    }
    return 0;
}
```

9. 骑士的移动（Knight Moves，uva1600）
------
解题思路：这个题就是告诉你起点和终点，让你找最短路，就是移动方式有点独特。挺简单的一个题，bfs求最短路。
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>

using namespace std;
struct node{
    int x,y,cnt;
    node(){
        x = y = cnt = 0;
    }
};
string s1,s2;
int dir[8][2] = {{-2,1},{-2,-1},{-1,2},{-1,-2},{1,-2},{1,2},{2,1},{2,-1}};
int vis[9][9];

void bfs(node begin,node end){
    memset(vis,0,sizeof(vis));
    queue<node> q;
    q.push(begin);
    vis[begin.x][begin.y] = 1;
    while(!q.empty()){
        node a;
        a = q.front();
        q.pop();
        if(a.x == end.x && a.y == end.y){
            cout << "To get from " << s1 << " to " << s2 <<" takes " << a.cnt <<" knight moves." << endl;
            break;
        }
        for(int i = 0;i < 8;i++){
            node b = a;
            b.x += dir[i][0];
            b.y += dir[i][1];
            if(!vis[b.x][b.y] && b.x >= 0 && b.x < 8 && b.y >= 0 && b.y < 8){
                b.cnt++;
                vis[b.x][b.y] = 1;
                q.push(b);
            }
        }
    }
}

int main(){
    while(cin >> s1 >> s2){
        node begin,end;
        begin.x = s1[0] - 'a';
        begin.y = s1[1] - '1';
        end.x = s2[0] - 'a';
        end.y = s2[1] - '1';
        bfs(begin,end);
    }
    return 0;
}
```