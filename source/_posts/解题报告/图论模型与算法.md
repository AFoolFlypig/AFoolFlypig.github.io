---
title: 图论模型与算法
date: 2018-03-21 21:59:35
categories: 解题报告
tags: 
- c/c++
- 算法
- 图论
---

1. 苗条的生成树(Slim Span,uva1395)
======
解题思路:这个题用kruskal算法做,要想找出来这个苗条度最小的生成树，就要先枚举这个区间的左端点，在此基础去枚举右端点，比如说有三个权值是3,4,5的边，首先是[3,4,5],[4,5],[5]分别去建树，然后比较苗条度，取最小的，这样，所有的方案都建成之后，最小的苗条度也就出来了.当然，边要足够连接所有的点，建不了树是没有结果的，返回-1.
<!--more-->
```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

const int maxn = 100 + 10;
const int maxm = 5000;
const int INF = 1000000;
int n,m,p[maxn];

struct edge{
    int begin,end,weight;
    edge(int a = 0,int b = 0,int c = 0){
        begin = a;
        end = b;
        weight = c;
    }
};
edge edges[maxm];

bool cmp(edge a,edge b){
    return a.weight < b.weight;
}

int find(int i){
    if(i == p[i]) return i;
    else return p[i] = find(p[i]);
}

int main(){
    while(scanf("%d%d",&n,&m) == 2 && n){
        for(int i = 1;i <= m;i++){
            scanf("%d%d%d",&edges[i].begin,&edges[i].end,&edges[i].weight);
        }
        sort(edges + 1,edges + m + 1,cmp);
        int ans = INF;
        for(int i = 1;i <= m;i++){
            for(int k = 1;k <= n;k++) p[k] = k;
            int cnt = n;
            for(int j = i;j <= m;j++){
                int x = find(edges[j].begin),y = find(edges[j].end);
                if(x != y){
                    p[x] = y;
                    if(--cnt == 1){
                        ans = min(ans,edges[j].weight - edges[i].weight);
                        break;
                    }
                }
            }
        }
        if(ans == INF) ans = -1;
        printf("%d\n",ans);
    }
    return 0;
}
```

2. 最短路
======

> 问题描述

> 给定一个n个顶点，m条边的有向图（其中某些边权可能为负，但保证没有负环）。请你计算从1号点到其他点的最短路（顶点从1到n编号）。
输入格式

> 第一行两个整数n, m。

> 接下来的m行，每行有三个整数u, v, l，表示u到v有一条长度为l的边。
输出格式
共n-1行，第i行表示1号点到i+1号点的最短路。
样例输入
3 3
1 2 -1
2 3 -1
3 1 2
样例输出
-1
-2
数据规模与约定

> 对于10%的数据，n = 2，m = 2。

> 对于30%的数据，n <= 5，m <= 10。

> 对于100%的数据，1 <= n <= 20000，1 <= m <= 200000，-10000 <= l <= 10000，保证从任意顶点都能到达其他所有顶点。

解题思路:这个题因为有负权边,所以dijkstra算法不能用,应该用Bellman-Ford算法.但是Bellman-Ford算法有一个问题,运行效率太低,会超时.应该用SPFA算法优化.下面给出两个方法的代码.

这个是直接的Bellman-Ford算法.
```cpp
#include<cstdio>
#include<algorithm>

using namespace std;
const int maxn = 20000 + 10;
const int maxm = 200000 + 10;
const int INF = 2e9 + 10;

struct edge{
    int u,v,w;
    edge(int a = 0,int b = 0,int c = 0){
        u = a;
        v = b;
        w = c;
    }
};
int n,m,d[maxn];
edge edges[maxm];

int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= m;i++)
        scanf("%d%d%d",&edges[i].u,&edges[i].v,&edges[i].w);
    for(int i = 1;i <= n;i++) d[i] = INF;
    d[1] = 0;
    for(int i = 1;i < n;i++){
        for(int j = 1;j <= m;j++){
            int x = edges[j].u,y = edges[j].v;
            d[y] = min(d[y],d[x] + edges[j].w);
        }
    }
    for(int i = 2;i <= n;i++)
        printf("%d\n",d[i]);
    return 0;
}
```
下面是优化后的算法,Bellman-Ford算法中的结点可以多次入队.
```cpp
#include<cstdio>
#include<queue>
#include<vector>
#include<cstring>

using namespace std;
const int maxn = 20000 + 10;
const int INF = 2e9 + 10;
const int maxm = 200000 + 10;

struct edge{
    int u,v,w;
    edge(int a = 0,int b = 0,int c = 0){
        u = a;
        v = b;
        w = c;
    }
};
edge edges[maxm];
vector<int> G[maxn];
int n,m,d[maxn],cnt[maxn];
bool inq[maxn];

bool bellman(int s){
    for(int i = 0;i < n;i++) d[i] = INF;
    d[s - 1] = 0;
    memset(inq,0,sizeof(inq));
    memset(cnt,0,sizeof(cnt));
    queue<int> q;
    q.push(s - 1);
    inq[s - 1] = true;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        inq[u] = false;
        for(int i = 0;i < G[u].size();i++){
            edge& e = edges[G[u][i]];
            if(d[e.v - 1] > d[u] + e.w && d[u] < INF){
                d[e.v - 1] = d[u] + e.w;
                if(!inq[e.v - 1]){
                    q.push(e.v - 1);
                    inq[e.v - 1] = true;
                    if(++cnt[e.v - 1] > n) return false;
                }
            }
        }
    }
    return true;
}

int main(){
    scanf("%d%d",&n,&m);
    int num = 0;
    for(int i = 0;i < m;i++){
        scanf("%d%d%d",&edges[i].u,&edges[i].v,&edges[i].w);
        int u = edges[i].u;
        G[u - 1].push_back(num);
        num++;
    }
    bellman(1);
    for(int i = 1;i < n;i++)
        printf("%d\n",d[i]);
    return 0;
}
```