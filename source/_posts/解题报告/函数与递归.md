---
title: 函数与递归
date: 2018-02-07 17:46:03
categories: 解题报告
tags: 
- c/c++
- 竞赛
---
好歹是把第三章搞过去了，虽然说习题就做了一半。在学习过程中很感谢小明，给了我不少帮助，我也没少麻烦了他。不扯了，下面进入正题。
<!--more-->

1. 古老的密码（Ancient Cipher,Uva1339）
------
解题思路：这个题我一开始没有思路，看了书上的分析才会做。**每个字母的顺序并不重要，重要的是每个字母出现的次数**。统计两个字符串中每个字符出现的次数，分别放到两个数组中，对这两个数组进行排序，只要排序后两个数组相同，输入的两个串就可以通过重排列和一一映射变得相同。
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAX 105

using namespace std;

int main(){
    char a[MAX],b[MAX];
    while(scanf("%s%s",a,b) != EOF){
        int len = strlen(a);
        int alpha_a[26] = {0},alpha_b[26] = {0};
        for(int i = 0;i < len;i++){
            alpha_a[a[i] - 'A']++;
            alpha_b[b[i] - 'A']++;
        }
        sort(alpha_a,alpha_a + 26);
        sort(alpha_b,alpha_b + 26);
        bool flag = true;
        for(int i = 0;i < 26;i++){
            if(alpha_a[i] != alpha_b[i]){
                flag = false;
                break;
            }
        }
        if(flag == true) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```

2. 刽子手游戏（Hangman Judge,Uva 489）
------
解题思路：我是用数组将计算机想的单词中有的字母都统计出来，然后再看数组中是否有猜测的单词中的字母。这里有一个注意点**如果胜利，一定要跳出循环**，不然的话，下面这个测试数据的结果是错的。

>		1
		a
		absdfghjklrtygfhfghfdhgfjhgvjybnmbmbnc
	
**以后能不用getchar()函数就不用，太容易出现错误**，下面是代码。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define MAX 100
#define ANUM 26

using namespace std;

bool judge(int *a,int n){
    for(int i = 0;i < n;i++)
        if(a[i] == 1) {return false; break;}
    return true;
}

int main(){
    int num;
    scanf("%d",&num);
    while(num != -1){
        char s1[MAX];
        scanf("%s",s1);
        int alpha[ANUM] = {0};
        for(int i = 0;i < strlen(s1);i++){
            alpha[s1[i] - 'a'] = 1;
        }
        int n = 0;
        char s2[MAX];
        scanf("%s",s2);
        for(int i =0;i < strlen(s2);i++){
            if(alpha[s2[i] - 'a'] == 1)
                alpha[s2[i] - 'a'] = -1;
            else n++;
            if(n < 7 && judge(alpha,ANUM)) break;
        }
        printf("Round %d\n",num);
        if(n < 7 && judge(alpha,ANUM)) printf("You win.\n");
        else if(n < 7 && !judge(alpha,ANUM)) printf("You chickened out.\n");
        else printf("You lose.\n");
        scanf("%d",&num);
        }
    return 0;
}
```
3. 救济金发放（The Dole Queue ,uva 133）
------
解题思路：这个题我是用循环链表直接模拟的，但是我用循环链表写出来的代码几乎没有可读性，书上的方法很巧妙，值得学习。**这个题有一个需要特别注意的地方就是当两个官员选中的村民相邻的情况，需要特殊处理，也就是我代码43-45行的处理**。

```cpp
#include<cstdio>
#include<iostream>

using namespace std;

typedef struct node{
    int data;
    struct node *front;
    struct node *next;
}Node;

int main(){
    int n,k,m;
    while(scanf("%d%d%d",&n,&k,&m) == 3 && n){
        int num = n;
        Node *pk = new Node,*pm = NULL;
        pk->data = 1;
        pk->front = pk;
        pk->next = pk;
        Node *q = pk;
        for(int i = 2;i <= n;i++){
            Node *p = new Node;
            p->data = i;
            p->front = q;
            q->next = p;
            q = p;
        }
        pm = q;
        pm->next = pk;
        pk->front = pm;
        while(num > 0){
            for(int i = 0;i < k - 1;i++){
                pk = pk->next;
            }
            for(int i = 0;i < m - 1;i++){
                pm = pm->front;
            }
            if(pk->data != pm->data){
                printf("%3d",pk->data);
                pk->next->front = pk->front;
                pk->front->next = pk->next;
                q = pk;
                if(pk->next == pm)
                    pk = q->next->next;
                else pk = q->next;
                delete q;
                num--;
                printf("%3d",pm->data);
                pm->next->front = pm->front;
                pm->front->next = pm->next;
                q = pm;
                pm = q->front;
                delete q;
                num--;
            }
            else{
                printf("%3d",pk->data);
                pk->next->front = pk->front;
                pk->front->next = pk->next;
                q = pk;
                pk = q->next;
                pm = q->front;
                delete q;
                num--;
            }
            if(num > 0)
                printf(",");
        }
        printf("\n");
    }
    return 0;
}
```

4. 信息解码（Message Deconding，uva213）
------
解题思路：这个题很典型，刘汝佳的二进制的表示真是巧妙，**定义一个数组codes[len][value]，其中len是编码长度，value是编码对应的十进制值，这样的话数组就和二进制编码一一对应了起来，用这个数组保存编码所对应的字符**。还有那个**readchar()函数**，很好理解，但是我以前却没有想到，这是一个非常好的读取多行字符的方法。还有那个**左移运算符的使用**，感觉很形象，很棒。
附上我的渣渣代码
```cpp
#include<cstdio>
#include<cstring>
#define MLEN 7
#define NUM 3

using namespace std;

char readchar(){
    char ch;
    while(1){
        ch = getchar();
        if(ch != '\n') return ch;
    }
}

char codes[8][1 << 8];

int main(){
    memset(codes,0,sizeof(codes));
    codes[1][0] = getchar();
    while(codes[1][0] != EOF){
//        printf("%c\n",codes[1][0]);
        for(int i = 2;i <= MLEN;i++){
            int k = 0;
            for(int j = 0;j < (1<<i) - 1;j++){
                codes[i][j] = getchar();
                if(codes[i][j] == '\n') {k = j ;break;}
            }
            if(codes[i][k] == '\n') break;
        }
        while(1){
            int len = 0;
            int num = NUM;
            while(num--){
                len = len * 2 + readchar() - '0';
            }
    //        printf("%d\n",len);
            if(len == 0) break;
            while(1){
                int k = len,ch = 0;
                while(k--){
                    ch = ch * 2 + readchar() - '0';
                }
                if(ch == (1<<len) - 1) break;
                printf("%c",codes[len][ch]);
            }
        }
        printf("\n");
        getchar();
        codes[1][0] = getchar();
    }
    return 0;
}
```
另外说一下刘汝佳大神的代码，他的代码写的真是棒，无论是构思还是布局，真是厉害。