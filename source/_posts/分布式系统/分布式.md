---
title: 分布式
date: 2023-07-16 10:50:37
categories: 分布式系统
mathjax: true
tags: 
- 分布式
---
# 1 全局唯一ID

<!--more-->

全局唯一ID一般需要满足以下几点要求：

- **全局唯一**：不能出现重复的ID，这是最基本的。
- **趋势递增**：多数关系型数据库都是使用B+树的数据结构来存储索引数据的，因此我们应该尽量使用有序的主键保证写入性能。
- **信息安全**：如果我们的ID是连续的，比如我们用这一ID作为订单号，那么竞争对手就可以直接知道我们一天的订单数量。所以一些应用场景下，会需要ID无规则、不规则。

简单来说，就是全局唯一、趋势递增且无规律。

## 1.1 雪花算法

雪花（snowflake）算法是Twitter开源的分布式ID生成算法，其产生的ID是一个64位的长整型。

![](分布式/fig1.png)

- **符号位**：1bit，永远为0
- **时间戳**：41bit，单位为毫秒
- **工作机器ID**：10bit，标识该分布式ID是在哪台机器上产生的，通过工作机器ID的唯一保证该分布式ID的唯一。
- **序列号**：毫秒内的递增序列号

雪花算法单机每秒理论上最多可以生成$1000 * (2^{12})$（每毫秒生成$2^{12}$个分布式ID，1秒为1000毫秒），也就是$409.6$万个ID。

由于雪花算法生成的分布式ID高位是时间戳，因此该分布式ID是趋势递增的，而且由于工作机器ID是唯一的，因此整个分布式ID也是唯一的。另外，**雪花算法不需要依赖其他的第三方系统就可以生成全局唯一ID**。

但是**雪花算法强依赖机器时钟，如果发生时间回拨可能会导致生成的ID重复**。

## 1.2 薄雾算法

薄雾（Mist）算法生成的ID同样是64位：

![](分布式/fig2.webp)

- **符号位**：1bit，永远为0
- **自增数**：47bit，递增且唯一。
- **随机数1**：8bit，使结果值不可预测。
- **随机数2**：8bit，使结果值不可预测。

薄雾算法中，自增数放在高位，能够保证生成的ID趋势递增，因此低位就可以为所欲为。所以薄雾算法生成的ID里面低16位放置了两个8位的数据数，用于保证ID的无规律性。另外，该自增数是唯一的，因此也可以保证所生成ID的唯一性。

一般来说，我们可以使用Redis来存储该自增数并实现自增。

## 1.3 雪花算法时钟回拨问题

前文中提到过，雪花算法是强依赖于机器时钟的，如果发生时钟回拨，可能会产生重复的ID，这是我们所不能接受的。

要想解决时钟回拨问题，我们首先需要判断当前时钟是否发生了回拨。我们可以使用一个变量记录上一次生成ID的时间戳，每次生成ID的时候，都与我们记录的时间戳进行比较，如果当前时间戳在其之前，说明发生了时钟回拨。

当发生了时钟回拨之后，我们可以使用以下几种解决方案：

- **直接抛出异常**。
- **等待时钟校正**。线程睡眠或者自旋，直到当前时间戳大于我们所记录的上一时间戳。
  - 适用于回拨幅度小的场景。
  - 可限定校正的次数，超过最大校正次数，直接抛出异常。
  - 对实时性要求较高的任务不友好。
- **使用历史序列号**。在出现时钟回拨时，使用上一时间戳的序号来继续累加。
  - 比如上一秒是0时0分0秒，自增序号到达了$x$。由于时钟回拨，下一秒时间是23时59分0秒，那么下一次生成序号时，发现当前时间戳小于上一时间戳，则使用0时0分0秒这一时间戳，自增序号使用$x+1$（实际上雪花算法是以毫秒为单位的，这里只是为了方便举例）。
  - 自增序列号用完之后要怎么办？重新等待？
- **时间戳自增**。不使用机器的时间戳，而是自己控制时间戳。当序列号自增超过最大值时（即溢出），时间戳自增1。
  - 生成的ID中的时间戳，并不是真实的时间，如果不使用从ID中解析出的时间戳，那么可以忽略这一点。
  - 可以与上面使用历史序列号这一方法相结合。如果历史序列号自增溢出时，可以将时间戳自增1，直到机器时间戳大于等于当前计算的时间戳为止。

**参考资料**：

[忘掉 Snowflake，感受一下性能高出 587 倍的全局唯一 ID 生成算法](https://segmentfault.com/a/1190000023087471)

[分布式唯一id：snowflake算法思考](https://juejin.cn/post/6844903562007314440)

[ 分布式系统 - 全局唯一ID实现方案](https://pdai.tech/md/arch/arch-z-id.html#mist-%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95)

[雪花算法与时间回拨](https://www.modb.pro/db/139829)

[雪花算法snowflake分布式id生成原理详解，以及对解决时钟回拨问题几种方案讨论](https://blog.51cto.com/stefanxfy/4722168#_414)

# 2 布隆过滤器

布隆过滤器（Bloom Filter）主要用于判断一个元素是否在一个集合中。

布隆过滤器是由一个固定大小的二进制数组或位图（bitmap）和一系列哈希函数组成的。

在初始状态时，对于长度为$m$的二进制数组，它的所有位都被置为0，如下图所示：

![](分布式/fig3.jpg)

当有元素被加入集合中，通过$k$个哈希函数对该元素进行哈希，得到$k$个下标，将对应下标的二进制数组元素置为1。

![](分布式/fig4.jpg)

当我们查询某个元素是否存在于集合中时，只需要使用上述$k$个哈希函数对该元素进行哈希，得到$k$个下标，然后查看这$k$个下标对应的二进制数组元素值：

- 如果有一个为0，则被查询元素**一定不存在**。
- 如果都是1，则被查询元素**可能存在**。

布隆过滤器的缺点：

- **存在误判**。
  - 布隆过滤器只能判断某个元素**一定不存在或可能存在**，当判断结果为存在的时候，元素不一定存在。
  - 随着存入的元素数量增加，误判率随之增加。
  - 可以通过增加二进制数组长度的方式减小误判率。
- **布隆过滤器只能添加元素，不能删除**。

那么我们可不可以让布隆过滤器支持删除呢？可以！

我们可以使用布隆过滤器的一个变种——计数布隆过滤器（Counting Bloom Filter）。原理就是将二进制数组中的二进制位升级为计数器（Counter）：

- 添加元素，对应的Counter分别加1。
- 删除元素，对应的Counter分别减1。

用多占用几倍存储空间的代价，给布隆过滤器增加了删除操作。

还有另外一种解决方案就是布谷鸟过滤器，这里就不展开介绍了。

**参考资料**：

[布隆过滤器，没那么难](https://segmentfault.com/a/1190000024566947)

[布隆，牛逼！布谷鸟，牛逼！](https://segmentfault.com/a/1190000039156246)

# 3 JWT

## 3.1 介绍

**JWT（Json Web Token）**也是一种token，其与普通token的区别在于：

- 使用普通token时，除了发送给客户端之外，服务器也要存储一份token（存储在session或者redis中），而验证普通token时要进行数据的查询操作。
- 使用JWT时，服务器是不需要存储token的，验证token时使用密钥校验（验签）即可，而不需要进行查询。

## 3.2 JWT组成

实际的JWT如下所示：

![](分布式/fig6.jpg)

它是一个很长的字符串，中间用点号$.$分隔成三个部分。JWT的三部分组成分别如下：

- Header（头部）
- Payload（载荷）
- Signature（签名）

写成一行，就是下面的样子：

```
Header.Payload.Signature
```

下面依次介绍这三部分。

### 3.2.1 Header

JWT的Header部分是一个JSON对象，描述JWT的元数据，通常是下面的样子：

```json
{
  'typ': 'JWT',
  'alg': 'HS256'
}
```

其中：

- `typ`属性表示这个token的类型，JWT令牌统一写为`JWT`。
- `alg`属性表示签名的算法，默认是HMAC SHA256，写做`HS256`。

将Header部分进行Base64URL编码后，就得到了JWT的第一部分。

### 3.2.2 Payload

Payload部分也是一个JSON对象，用来存放实际需要传递的数据。JWT规定了7个官方字段，供选用：

- `iss`（Issuer）：JWT签发者。
- `exp`（Expiration Time）：过期时间，该过期时间必须要大于签发时间。
- `sub`（Subject）：JWT所面向的用户，通常是能唯一标识该用户的标识符。
- `aud`（Audience）：接收JWT的一方。
- `nbf`（Not Before）：生效时间，表示JWT在这个时间后使用。
- `iat`（Issued At）：签发时间。
- `iti`（JWT ID）：签发JWT时给予当前token的唯一ID，通常用于一次性消费的token，从而回避重放攻击。

除了标准中定义的字段，我们还可以在这个部分定义私有字段，如下：

```json
{
    // 这里也可以是签发JWT的服务器的域名
    "iss": "John Wu JWT",
    "iat": 1441593502,
    "exp": 1441594722,
    "aud": "www.example.com",
    // 能够唯一标识目标用户的标识符，这里使用的是邮箱，像电话号码或者ID也可以
    "sub": "jrocket@example.com",
    // 下面两个是自己定义的私有字段
  	"name": "John Doe",
  	"admin": true
}
```

将Payload进行Base64URL编码后，就得到了JWT的第二部分。

### 3.2.3 Signature

Signature是对前面两部分的签名，防止数据被篡改。

首先需要指定一个密钥（secret），这个秘钥只有服务器自己知道。然后，使用Header中指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名：

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

其实就是将Header与Payload使用点号$.$连接起来，然后再对这一字符串进行签名。

算出签名之后，将这三部分使用点号$.$连接起来，就得到了JWT。

### 3.2.4 Base64URL

前面提到，对Header和Payload进行的Base64URL编码。这个算法与Base64类似，但有一些小的不同。

JWT作为一个token，有些场合可能会放到URL中。Base64中有三个字符`+`、`/`和`=`，在URL里面有特殊含义，所以要被替换掉。Base64URL将`+`替换成`-`，`/`替换成`_`，并去掉末尾填充的`=`。

## 3.3 JWT使用

客户端收到服务器返回的JWT，可以存储在Cookie里面，也可以存储在localStorage中。

此后，客户端每次与服务器通信，都要带上这个JWT。我们可以将其放在Coolie里面自动发送，但是这样不能进行跨域，所以更好的做法是将其放在HTTP请求头的`Authorization`字段中。

```htt
Authorization: Bearer <token>
```

通常，token前面要加上一个Bearer前缀，并用空格隔开（规范是这么要求的）。

客户端使用JWT访问服务器资源的流程如下：

![](分布式/fig2.png)

## 3.4 JWT的特点

- JWT默认是不加密的，但也可以进行加密。生成原始token后，可以用密钥再加密一次。
- JWT不加密的情况下，不能将诸如用户密码等保密信息写入JWT。
- JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。
- JWT的最大缺点是，服务器无法在使用过程中废止某个token，或者更改token的权限。也就是说，**一旦JWT签发了，在到期之前都会始终有效**，除非服务器部署额外的逻辑。
- JWT本身包含了认证信息，一旦泄露，任何人都可以获取该令牌的所有权限。为了减少盗用，JWT的有效期应该设置的比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。

**参考资料**：

[什么是 JWT -- JSON WEB TOKEN](https://www.jianshu.com/p/576dbf44b2ae)

[[ tool ] JWT认证 和base64编码](https://juejin.cn/post/7001821199550382117)

[JSON Web Token 入门教程](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

[一文详解 Base64 编码原理](https://www.cnblogs.com/xiaxveliang/p/15097947.html)

[JSON Web Token - 在Web应用间安全地传递信息](https://blog.leapoahead.com/2015/09/06/understanding-jwt/)

[JWT(Json Web Token)中默认的声明含义](https://llbetter.com/JWT-default-claims/)

# 4 OAuth2.0

## 4.1 介绍

OAuth2.0是一种授权协议，允许用户授权第三方应用访问他存储在另外服务商里的各种信息数据，而这种授权**不需要提供用户名和密码**。

在我们登录某些第三方应用时，可以使用相关社交账号（微信、QQ、微博）登录。传统的方式是，用户将自己社交账号（比如微信）的用户名和密码告诉第三方应用，但这样做会有很多问题：

- 第三方应用拥有了用户微信的所有权限，用户没有办法限制第三方应用获得**授权的范围和有效期**。
- 用户只有修改密码，才能收回赋予给第三方应用的权限，但是这样做会使得其他所有获得用户授权的第三方应用程序全部失效。
- 只要有一个第三方应用程序被破解，就会导致用户密码泄露，以及所有使用微信登录的第三方应用的数据泄露。

OAuth2.0的作用就是让“第三方应用”安全可控地获取“用户”的授权，与“服务提供商”进行交互。**本质是使用token令牌代替用户名密码（可指定token的权限范围和有效期）**。

## 4.2 OAuth2.0名词定义

- **Third-party application**：第三方应用程序，也被称为客户端（Client）。
- **HTTP service**：服务提供商，本文中指的是微信。
- **Resource Owner**：用户/资源拥有者，本文中指的是在微信中注册的用户。
- **Authorization server**：认证服务器，在资源拥有者授权后，向第三方应用授权（颁发Access Token）的服务器。
- **Resource server**：资源服务器，即服务提供商存放用户生成资源的服务器。它与认证服务器可以是同一台服务器，也可以是不同的服务器。

## 4.3 OAuth2.0授权流程

OAuth2.0的交互流程如下：

![](分布式/fig7.awebp)

1. 用户访问第三方应用之后，第三方应用要访问服务提供方，要求用户给予授权。
2. 用户同意给予第三方应用访问服务提供方的授权，并返回一个授权凭证。
3. 第三方应用使用上一步获得的授权凭证，向认证服务器申请令牌。
4. 认证服务器验证第三方应用的授权凭证通过后，同意授权，并返回一个资源访问的令牌。
5. 第三方应用程序使用令牌，向资源服务器请求相关资源。
6. 资源服务器验证令牌通过后，同意向第三方应用开放资源，返回第三方应用请求的资源。

下面是时序图：

![](分布式/fig8.awebp)

不难看出，上面6个步骤中，第2步是关键，即用户怎样才能给予第三方应用授权。有了这个授权之后，第三方应用就可以获取令牌，进而凭借令牌获取资源。

下一节讲解第三方应用获取授权的四种模式。

## 4.4 OAuth2.0的授权模式

OAuth2.0的授权模式主要有以下四种：

- 授权码模式（authorization code）
- 简化模式（implicit）
- 密码模式（Resource owner password credentials）
- 客户端模式（client credentials）

### 4.4.1 授权码模式

第三方应用先申请获取一个授权码，然后再使用该授权码获取令牌，最后使用令牌获取资源。授权码模式是功能最完整、流程最严密的授权模式。它的特点是通过第三方应用的后台服务器与服务提供商的认证服务器交互。

![](分布式/fig9.awebp)

步骤如下：

- A（步骤1,2）：用户访问第三方应用客户端，需要使用服务提供商的数据，因此第三方应用客户端将用户导向服务提供商的认证服务器（也称授权服务器）。
- B（步骤3）：用户选择是否给予第三方应用授权。
- C（步骤4）：假设用户同意授权，认证服务器将用户导向第三方应用事先指定的“重定向URI”（redirection URI），同时带上一个授权码。
- D（步骤5,6）：
  - 第三方应用客户端收到授权码，然后发送给第三方应用服务器。
  - 第三方应用服务器收到授权码后，附上授权码和早先的“重定向URI”，向认证服务器申请令牌。这一步是在第三方应用的后台的服务器上完成的，对用户不可见。
- E（步骤7,8）：
  - 认证服务器核对授权码和重定向URI，确认无误后，向第三方应用服务器发送访问令牌（access token）和更新令牌（refresh token）。
  - 第三方应用服务器将访问令牌（access token）发送给第三方应用客户端。
- F（步骤9,10）：
  - 第三方应用客户端携带access token向第三方应用服务器发起资源请求。
  - 客户端服务器再向服务提供商的资源服务器请求资源。
- G（步骤11,12,13）：
  - 资源服务器验证令牌通过后，向第三方应用服务器返回资源。
  - 第三方应用服务器再将数据回传给第三方应用客户端使用。

上面的F以及G步骤其实第三方应用客户端直接向服务提供商请求资源即可，感觉没必要再去经过第三方应用服务器，除非第三方应用服务器中要保存一份该资源。

A步骤中的**授权请求**示例如下：

```http
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

参数解释：

- `response_type`：必选项，表示授权类型，此处的值固定为`code`，表示使用授权码模式。
- `client_id`：必选项，第三方应用在服务提供商处注册时生成的ID。
- `redirect_uri`：可选项，表示重定向URI，接收或拒绝请求后的跳转网址。
- `scope`：可选项，表示申请的权限范围。
- `state`：可选项，表示第三方应用的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值（**为了防止CSRF攻击**）。

C步骤中的**授权响应**示例如下：

```http
HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
          &state=xyz
```

其中，`Location`指定的是重定向地址，一般在响应码为`3xx`的响应中才会有意义。

参数解释：

- `code`：必选项，表示授权码。

  - 该码的有效期应该很短，通常设为10分钟。

  - 客户端只能使用该码一次，否则会被认证服务器拒绝。
  - **该码与第三方应用的ID和重定向URI是一一对应的关系**。

- `state`：如果客户端的请求中包含这个参数，认证服务器的响应中也必须一模一样包含这个参数。

D步骤中的**令牌请求**示例如下：

```http
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code\
&code=SplxlOBeZQQYbYS6WxSbIA\
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\
&client_id=s6BhdRkqt3\
&client_secret=7Ft7ym8MpE54yWGUNvxxg6KqGwPFsyhYn9
```

参数解释：

- `grant_type`：必选项，表示使用的授权模式，此处的值固定为`authorization_code`。
- `code`：必选项，上一步获取的授权码。
- `redirect_uri`：表示重定向URI，如果A步骤中的授权请求中包含`redirect_uri`，那么就是必选项，且必须与授权请求中的该参数值保持一致。
- `client_id`：必选项，第三方应用在服务提供商处注册时生成的ID。
- `client_secret`：必选项，第三方应用在服务提供商处注册时生成的密钥。
  - 该密钥主要是为了防止伪造，用于确认第三方应用使用的`client_id`确实是第三方应用自己所持有的。
  - `client_secret`参数是保密的，因此只能在后端发送该请求（也就是说`client_secret`是不能保存在前端的）。

E步骤中的**令牌响应**示例如下：

```http
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"Bearer",
"expires_in":3600,
"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
"example_parameter":"example_value"
}
```

可以看出，相关参数使用JSON格式发送。另外，HTTP头信息中明确指定不得缓存。

参数解释：

- `access_token`：必选项，表示访问令牌。
- `token_type`：必选项，表示令牌类型，可以是`bearer`类型或`mac`类型。
- `expires_in`：可选项，表示过期时间，单位为秒。如果省略该参数，必须以其他方式设置过期时间。
- `refresh_token`：可选项，表示更新令牌，用来获取下一次的访问令牌。
- `scope`：表示权限范围，如果与客户端申请的范围一致，此项可省略。

### 4.4.2 简化模式

简化模式不通过第三方应用的后台服务器，而是直接在浏览器中向认证服务器申请令牌，跳过了授权码这个步骤，因此得名。所有步骤均在浏览器中完成，**令牌对访问者是可见的，不可刷新，且第三方应用不需要进行认证**（不需要根据`client_id`和`client_secret`对第三方应用进行验证，请求中只传递`client_id`）。

![](分布式/fig10.awebp)

步骤如下：

- A（步骤1,2）：用户访问第三方应用客户端，需要使用服务提供商的数据，因此第三方应用客户端将用户导向服务提供商的认证服务器（也称授权服务器）。
- B（步骤3）：用户选择是否给予第三方应用授权。
- C（步骤4）：假设用户同意授权，认证服务器将用户导向第三方应用事先指定的“重定向URI”（redirection URI），并在URI的hash部分添加访问令牌（access token）。
- D（步骤5）：第三方应用客户端携带access token向服务提供商的资源服务器发起资源请求。
- E（步骤6,7）：资源服务器验证令牌通过后，向第三方应用客户端返回资源。

A步骤中的**令牌请求**示例如下：

```http
GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

参数解释：

- `response_type`：必选项，表示授权类型，此处的值固定为`code`。
- `client_id`：必选项，第三方应用在服务提供商处注册时生成的ID。
- `redirect_uri`：可选项，重定向URI。
- `scope`：可选项，表示申请的权限范围。
- `state`：可选项，表示第三方应用的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。

C步骤中的**令牌响应**示例如下：

```http
HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
		  &state=xyz&token_type=bearer&expires_in=3600
```

参数解释：

- `access_token`：必选项，表示访问令牌。
- `token_type`：必选项，表示令牌类型，可以是`bearer`或`mac`。
- `expires_in`：可选项，表示过期时间，单位为秒。如果省略该参数，必须使用其他方式设置过期时间。
- `scope`：可选项，表示权限范围，如果与第三方应用申请的范围一致，此项可省略。
- `state`：如果第三方应用的请求中包含这个参数，认证服务器的响应中也必须一模一样包含这个参数。

上面的例子中，认证服务器用HTTP头信息的`Location`栏，指定浏览器重定向的URI。注意，这个URI的hash部分包含了令牌，即URI中`#`后面的部分。hash部分也称为锚（fragment）部分，`#`作为hash部分（或锚部分）的开头，其中`#`不属于哈希部分的值。

`#`是用来指导浏览器动作的，对服务端完全无用。所以，HTTP请求中不包括`#`及其后面的部分。

比如，访问下面的网址：

```
http://www.example.com/index.html#print
```

浏览器实际发出的请求是这样的：

```http
GET /index.html HTTP/1.1
Host: www.example.com
```

可以看到，只是请求`index.html`，根本没有`#print`的部分。

OAuth2.0在简化模式中之所以要将令牌放在URI中的hash部分，主要是因为浏览器跳转时，hash部分不会发到服务器，减少了泄露令牌的风险。

### 4.4.3 密码模式

密码模式中，用户向第三方应用提供自己用户名和密码，第三方应用使用这些信息，向服务提供商索要授权。

![](分布式/fig11.awebp)

步骤如下：

- A（步骤1,2）：用户向第三方应用提供自己在服务提供商处注册的用户名和密码。

- B（步骤3）：第三方应用将用户名和密码发给认证服务器，向后者请求访问令牌（access token）。

- C（步骤4）：认证服务器确认身份无误后，向客户端提供访问令牌。

B步骤中的**令牌请求**的示例如下：

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=johndoe&password=A3ddj3w
```

参数解释：

- `grant_type`：必选项，表示授权类型，此处的值固定为`password`。
- `username`：必选项，表示用户名。
- `password`：必选项，表示用户密码。
- `scope`：可选项，表示权限范围。

在密码模式中，不再需要`client_id`参数了，说明密码模式在第三方应用没有在服务提供商注册处的情况下也可以使用。

C步骤中的**令牌响应**示例如下：

```http
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"example",
"expires_in":3600,
"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
"example_parameter":"example_value"
}
```

这里面的参数就不展开了，前面都介绍过。

需要注意的是，令牌响应中包含`refresh_token`字段，所以密码模式下应该也是要经过第三方应用服务器来与认证服务器进行通信的。

### 4.4.4 客户端模式

客户端模式指第三方应用以自己的名义，而不是以用户的名义，向服务提供商进行认证。在这种授权场景下，不需要普通用户的参与，客户端从认证服务器获取到access token令牌后，使用这个令牌从资源服务器获取的资源也都是跟用户没有关联性质的数据。

这种授权模式应用的场景是B2B的服务授权调用，属于企业间数据授权和交互的范畴，并不存在用户向第三方应用授权。

![](分布式/fig12.png)

步骤如下：

- A：第三方应用向认证服务器进行身份认证，并要求一个访问令牌。
- B：认证服务器进行身份认证通过后，向第三方应用提供访问令牌。

A步骤中的**令牌请求**示例如下：

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```

- `grant_type`：必选项，表示授权类型，此处的值固定为`client_credentials`。
- `scope`：可选项，表示权限范围。

认证服务器必须以某种方式，验证客户端身份。一种方式是在请求中附加`client_id`和`client_secret`用来对第三方应用进行身份验证。

B步骤中的令牌响应示例如下：

```http
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"bearer",
"expires_in":3600,
"example_parameter":"example_value"
}
```

## 4.5 OAuth2.0更新令牌

如果用户访问的时候，第三方应用的访问令牌（access token）已经过期，则需要使用更新令牌（refresh token）申请一个新的访问令牌。

**更新令牌请求**的示例如下：

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```

- `grant_type`：必选项，表示使用的授权模式，此处的值固定为`refresh_token`。
- `refresh_token`：必选项，表示第三方应用收到的refresh token。
- `scope`：可选项，表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。

**令牌响应**示例如下：

```http
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"example",
"expires_in":3600,
"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
"example_parameter":"example_value"
}
```

[理解OAuth 2.0](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)

[[简易图解]『 OAuth2.0』 『进阶』 授权模式总结](https://learnku.com/articles/20082)

[Web服务端应用的OAuth2.0接入流程](https://help.aliyun.com/document_detail/175894.html)

[OAuth2.0—简化授权模式详解](https://www.coding10.com/section/oauth2-implicit-grant-type)

[OAuth2.0—客户端模式详解](https://www.coding10.com/section/oauth2-client-credentials-grant-type)

# 5 Raft算法

## 5.1 状态机复制

在分布式环境中，如果我们要让一个服务具有容错能力，那么最常用最直接的方法就是让一个服务的副本同时运行在不同的节点上。但是，当一个服务的多个副本都在运行的时候，我们如何保证它们的状态都是同步的呢？或者说，如果让客户端看起来无论请求发送到哪一个服务器副本，最后都能得到相同的结果？实现这种同步的方法就是所谓的状态机复制（State Mache Replication）。

状态机复制的理论基础是：如果集群中的每个节点上都运行着相同的**确定性状态机**$S$，并且所有的状态机都处于同样的初始状态$s_{0}$，那么给予这些状态机相同的输入序列$\{i_{1}, i_{2}, \dots, i_{n}\}$，这些状态机必然后经过相同的状态转换路径$s_{0} \to s_{1} \to s_{2} \to \dots \to s_{n}$，最终到达相同的状态$s_{n}$，同时生成相同的输出序列$\{o_{1}, o_{2}, \dots, o_{n}\}$。简单来说，就是**相同的初始状态 + 相同的输入 = 相同的结束状态**。

状态机复制使得多个节点具有完全相同的状态，运行完全相同的确定性状态机，这多个节点组成一个整体对外服务，其中部分节点失效不影响整体的可用性。

在执行输入序列的过程中，根据同步方式的不同，系统就有了强一致性和最终一致性。如果我们要求对于序列中的每一个$i_{n}$，都需要所有的服务副本确认成功执行了$i_{n}$，才能执行$i_{n+1}$，那么这个系统就是**强一致性**的系统。如果我们取消掉这个限制，仅仅要求所有的服务副本执行相同的输入序列，但是完全独立执行，而不需要在中间同步，那么就有了**最终一致性**（各服务都会到达相同的最终状态，但是到达的时间不确定）。

**共识算法**其实就是实现状态机复制的一种方法，使得多个节点达到相同的数据状态，从而保证分布式系统的一致性。即使遇到机器宕机，整个系统仍然能够对外保持服务的可用性。

![](分布式/fig13.png)

状态机复制通常都是基于日志复制实现的，如上图。

## 5.2 Raft介绍

Raft将共识问题分解为如下三个子问题：

- **Leader election（领导者选举）**：当集群启动或者leader宕机时，必须通过选举机制选出新的leader。
- **Log replication（日志复制）**：leader必须接收客户端提交的日志，并将其复制到集群中的其他节点，强制其他节点的日志与leader一致。
- **Safety（安全性）**：通过安全性原则来处理一些特殊case，保证Raft算法的完备性。

所以，Raft算法的核心流程可以归纳为：

- 首先选出leader，leader节点负责接收客户端的请求，并将请求追加到日志中。
- 然后leader将日志复制到其他follower节点，同时通过安全性准则来保证整个日志复制的一致性。
- 如果leader宕机，follower节点会重新发起选举选出新的leader。

下面首先介绍一下Raft算法中的基本概念，然后再分别介绍每个子问题。

## 5.3 Raft基本概念

### 5.3.1 state（状态）

在Raft中，一个节点任时刻都会处于以下三种状态之一：

- **leader**：leader负责处理客户端的所有请求（如果客户端请求发送给了follower，follower会将请求重定向至leader）。
- **follower**：follower不会主动发起请求，只是对leader与candidate的请求做出响应。
- **candidate**：用于选出新的leader。

几种状态的转换如下：

![](分布式/fig14.png)

- follower
  - 初始时所有节点都是follower。
  - 如果一段时间内没有收到来自leader的心跳，从follower切换到candidate，发起选举竞选leader。
- candidate
  - 如果candidate获得了半数以上的投票，则转为leader。
  - 如果选举超时，重新发起选举。
  - 如果发现已存在leader或者更高任期的节点，转化为follower。
- leader
  - 如果leader发现存在更高任期的节点，则转化为follower。

### 5.3.2 term（任期）

Raft将时间划分为任意长度的**term（任期）**，如下所示：

![](分布式/fig15.png)

任期使用连续的整数标识，并且每一段任期从一次选举开始。

- 如果选举成功，选出的leader将会管理整个集群，直到任期结束。
- 如果选举失败，这个任期将会由于没有leader而结束。

Raft保证了在每一段任期中，最多只会有一个leader（0个或1个）。

每个节点都会存储一个当前任期号，这一编号是单调递增的。当节点之间通信的时候会交换当前任期号：

- 如果一个节点的当前任期号小于其他节点，则更新该节点的当前任期号。
- 如果一个candidate或leader发现自己的任期号过期了，那么它们会转化为follower状态。
- 如果一个节点收到一个包含过期任期号的请求，那么该结点会直接拒绝这一请求。

### 5.3.3 RPC

Raft算法中节点之间的通信使用**远程过程调用（Remote Procedure Call，RPC）**，基本的Raft算法只需要两种RPC：

- **RequestVote RPC**： 请求投票RPC，由candidate在选举期间发起。
- **AppendEntries RPC**：追加条目RPC，由leader发起，用于复制日志和提供一种心跳机制。

这两种RPC的具体内容下面再细讲。

## 5.4 Leader election

Raft使用**心跳机制**触发领导者选举。leader在任期内会周期性地向所有follower节点发送心跳消息（不携带log entry的AppendEntries RPC）来维持自己的地位，阻止新leader的产生。

每个follower都设置了一个**随机**的**竞选超时时间（election timeout）**，一般为150ms~300ms。如果follower在竞选超时时间内没有收到leader的心跳消息，就会认为当前集群中不存在leader，此时follower会发起选举来选出一个新的leader。需要注意的是，当follower收到来自其他节点的消息之后都会重置竞选超时时间，不管是leader还是candidate，而不只是leader的心跳消息。

发起一个选举时，follower会先将自己的当前任期号加一，并且状态转化为candidate。该candidate首先会投票给自己，然后并行的向集群中的其他结点发送投票请求（RequestVote RPC）。选举结果有三种情况：

- 该节点赢得选举，成为leader。
  - 当一个candidate获得集群中**半数以上**节点的投票之后，该节点赢得选举，成为leader。这一规则确保了集群中最多只会有一个leader。
  - 当节点成为leader后，会向其他节点发送心跳消息，从而确定自己的leader地位，阻止新一轮的选举。
  - 每个节点在一个任期中只能投出一张选票，按照先来先服务的原则投出。
- 其他结点赢得选举，成为leader。
  - 在等待投票的过程中，candidate可能会收到其他节点声明自己是leader的AppendEntries RPC。
  - 如果该RPC中的任期号不小于candidate当前的任期号，则candidate会承认该leader合法并回到follower状态。
  - 否则，拒绝这一请求，继续保持candidate状态。
- 无节点赢得选举，无leader。
  - 如果有多个follower同时成为candidate，那么选票可能会被瓜分以至于没有一个candidate可以赢得半数以上的投票。
  - 上述情况发生时，每一个candidate都会竞选超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他的机制的话，选票可能会被无限的重复瓜分。
  - Raft算法使用随机的竞选超时时间（election timeout）的方法来解决上述问题。
    - 在大多数情况下，只有一个节点会超时，然后其赢得选举，成为leader，并在其他节点超时之前发送心跳消息。
    - 同样的机制也被用在选票瓜分的情况下。每一个candidate在开始一次选举时会重置一个随机的竞选超时时间，然后在超时时间内等待投票的结果，减少了新的选举中发生选票瓜分的可能性。

## 5.5 Log replication

在一个Raft集群中，只有leader节点能够处理客户端的请求（如果客户端的请求发送给了follower，follower会将请求重定向到leader）。

客户端的每一个请求都包含一条待状态机执行的命令，leader会将该命令作为一个新的日志条目（entry）追加到日志中，然后并行的向所有follower发送AppendEntries RPC以复制该entry。

当该entry被安全复制（后面会详细说）之后，leader会将该日志应用到自己的状态机中，并将执行结果返回给客户端。如果follower崩溃或者运行缓慢，又或者网络丢包，leader会不断重发AppendEntries RPC（即使已经向客户端返回了响应），直到所有的follower最终都存储了所有的日志条目为止。

Raft中的日志条目（entry）由三部分组成：

- 索引号。用于表明entry在日志中的位置。
- 任期号。用来检查是否出现不一致的情况。
- 状态机需要执行的命令。

![](分布式/fig20.png)

Raft日志复制保证以下两点，这两点组合起来就构成了Log Matching Property：

- 如果不同日志中的两个日志条目有着相同的索引号和任期号，则它们所存储的命令是相同的。

  > 这个特性基于这条原则：leader最多在一个term内，在指定的一个日志索引上创建一条日志条目，同时日志条目在日志中的位置不会改变。

- 如果不同日志中的两个日志条目有着相同的索引号和任期号，则它们之前的所有条目都是完全一样的。

  > 这个特性由AppendEntries RPC的一致性检查保证。在发送AppendEntries RPC时，leader会把新日志条目之前的日志条目的索引号和任期号一起发送。如果follower在它的日志中找不到包含相同索引号和任期号的日志条目，它就会拒绝接收新的日志条目。

一般情况下，leader和follower的日志能够保持一致，因此AppendEntries RPC的一致性检查通常不会失败。然而，leader崩溃可能会导致日志不一致（旧的leader可能没有复制完日志中的所有条目）。

![](分布式/fig21.png)

Raft中，**leader通过强制follower复制它的日志来处理日志的不一致**，follower上不一致的日志会被leader的日志覆盖。

leader为了使follower的日志同自己的一致，leader需要找到follower同它的日志相同的位置，然后覆盖follower在该位置之后的条目。上述操作是基于AppendEntries RPC一致性检查的检查结果实现的。

- leader中会为每个follower维持一个`nextIndex`属性，即leader要发送给follower的日志条目的索引号。当leader当选之后，它会初始化该属性为自己最新的索引号+1，在上图中为11。
- 如果follower的日志与leader的不一致，则AppendEntries RPC的一致性检查会失败。收到失败的返回之后，leader会将该follower对应的`nextIndex`减一，然后重发AppendEntries RPC。
- 最终`nextIndex`会到达leader与follower日志相一致的位置，AppendEntries RPC成功执行，后续不一致的日志条目都会被覆盖，follower的log又变得与leader一致了。

有了上面的知识之后，现在我们可以说一下Raft的log replication流程了，log replication主要可分为如下几步：

1. **客户端发送请求到leader。**leader在收到请求后，会将请求中的命令作为日志条目（entry）写入自己的本地日志中。需要注意的是，此时该entry的状态是未提交的，leader并不会在状态机中执行该命令。

2. **leader将entry发送到其他follower。**leader并行的向所有follower发送AppendEntries RPC以复制该entry。

3. **leader等待follower回应**。follower接收到leader的AppendEntries RPC后，有两种可能的回应：

   - leader将entry写入到自己的本地日志中，返回true。
   - 一致性检查失败，返回写入，返回false。此时leader会将该follower对应的`nextIndex`减一，然后重发AppendEntries RPC，直到follower返回成功为止。

   当半数以上的follower都成功复制该entry之后，leader会将第一步中写入的entry标记为提交状态，并将该entry应用到它的状态机中。提交最新的entry时会将之前所有未提交的entry一并提交（这个后面会细讲）。

4. **leader回应客户端**。完成上述三步之后，leader会向客户端返回执行结果，表示命令执行成功。需要注意的是，如果follower崩溃或者运行缓慢，又或者网络丢包，leader会不断重发AppendEntries RPC（即使已经向客户端返回了响应），直到所有的follower最终都存储了所有的日志条目为止。

5. **leader通知follower entry已提交**。leader回应客户端后，将随着下一个心跳通知follower entry已提交，follower收到通知后也会将entry标记为提交状态，并将该entry应用到自己的状态机中。

## 5.6 Safety



**参考资料**：

[状态机复制 (State Machine Replication)](https://netium.gitlab.io/2018/09/12/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6-(State-Machine-Replication)/)

[Raft 算法概述](https://www.lixueduan.com/posts/distributed/raft/)

[分布式一致性算法Raft](http://dockone.io/article/2434665)

[深入剖析共识性算法 Raft](https://segmentfault.com/a/1190000039847941)

[Raft 算法解读](https://www.sofastack.tech/projects/sofa-jraft/raft-introduction/)

[raft算法一致性的研究](https://learnku.com/articles/63852)

# 6 Gossip协议



# 7 限流算法

限流，也称流量控制，是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。限流会导致部分用户请求处理不及时或者被拒，这就影响了用户体验。所以一般需要在系统稳定和用户体验之间进行平衡。

常见的限流算法主要有以下几种：

- 固定窗口限流算法
- 滑动窗口限流算法
- 漏桶算法
- 令牌桶算法

其中，固定窗口限流算法与滑动窗口限流算法都属于计数器限流算法。下面对这几种限流算法依次进行介绍。

## 7.1 固定窗口限流算法

首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。

- 当次数小于限流阈值，就允许访问，并且计数器加一。
- 当次数大于限流阈值，就拒绝访问。
- 当前的时间窗口过去之后，计数器清零。

假设单位时间为1秒，限流阈值为3。在单位时间1秒内，没来一个请求，计数器加1，如果计数器累加的次数等于限流阈值3，后续的请求全部拒绝。等到1秒结束后，计数器清0，重新开始计数。

![](分布式/fig22.jpg)

伪代码如下：

```java
/**
  * 固定窗口时间算法
  * @return
  */
boolean fixedWindowsTryAcquire() {
    long currentTime = System.currentTimeMillis();  //获取系统当前时间
    if (currentTime - lastRequestTime > windowUnit) {  //检查是否在时间窗口内
        counter = 0;  // 计数器清0
        lastRequestTime = currentTime;  //开启新的时间窗口
    }
    if (counter < threshold) {  // 小于阀值
        counter++;  //计数器加1
        return true;
    }

    return false;
}
```

然而，这种算法有一个很明显的临界问题：**窗口切换可能会产生两倍于阈值流量的请求**。假设限流阈值为5，单位时间窗口为1秒。假设我们在0.8-1s这一时间段来了5个请求，没有超出限流阈值，此时计数器为5。然后窗口发生切换，计数器的值清0，假设在1-1.2s又来了5个请求，也没有超出限流阈值。但还是如果我们观察0.8-1.2s这一区间，在0.4s内并发量高达10，已经**超过了单位时间1s并发量不超过限流阈值5的要求**了。

![](分布式/fig23.jpg)

## 7.2 滑动窗口限流算法

滑动窗口限流算法解决了固定窗口限流算法中的临界问题。它将一个单位时间窗口分为n个小窗口，每个小窗口维护一个独立的计数器。根据时间滑动删除过期的小窗口，并添加新的小窗口，同时要保证整个窗口中所有小窗口的请求数目之和不能超过限流阈值。

![](分布式/fig24.jpg)

假设单位时间还是1s，滑动窗口算法将这一时间窗口划分为5个小窗口，每个小窗口表示0.2秒的时间周期。没过0.2s，时间窗口都会往右滑动一格（一个小窗口）。每个小窗口都有自己独立的计数器，如果请求是0.83s到达的，那么0.8-1对应的计数器就会加1。

不难看出，滑动窗口算法就是固定窗口的升级版。将计时窗口划分成一个小窗口，滑动窗口算法就退化成了固定窗口算法。而滑动窗口算法其实就是对请求数进行了更细粒度的限流，窗口划分的越多，那么滑动窗口的滚动就越平滑，限流就会越精准。

滑动窗口限流算法的伪代码如下：

```java
package com.wdbyte.rate.limiter;

import java.time.LocalTime;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 滑动窗口限流工具类
 *
 * @author https://www.wdbyte.com
 */
public class RateLimiterSlidingWindow {
    /**
     * 阈值
     */
    private int qps = 2;
    /**
     * 时间窗口总大小（毫秒）
     */
    private long windowSize = 1000;
    /**
     * 多少个子窗口
     */
    private Integer windowCount = 10;
    /**
     * 窗口列表
     */
    private WindowInfo[] windowArray = new WindowInfo[windowCount];

    public RateLimiterSlidingWindow(int qps) {
        this.qps = qps;
        long currentTimeMillis = System.currentTimeMillis();
        for (int i = 0; i < windowArray.length; i++) {
            windowArray[i] = new WindowInfo(currentTimeMillis, new AtomicInteger(0));
        }
    }

    /**
     * 1. 计算当前时间窗口
     * 2. 更新当前窗口计数 & 重置过期窗口计数
     * 3. 当前 QPS 是否超过限制
     *
     * @return
     */
    public synchronized boolean tryAcquire() {
        long currentTimeMillis = System.currentTimeMillis();
        // 1. 计算当前时间窗口
        int currentIndex = (int)(currentTimeMillis % windowSize / (windowSize / windowCount));
        // 2.  更新当前窗口计数 & 重置过期窗口计数
        int sum = 0;
        for (int i = 0; i < windowArray.length; i++) {
            WindowInfo windowInfo = windowArray[i];
            // 如果当前时间减去小窗口开始时间的值大于计时窗口大小，说明当前小窗口过期，重置小窗口开始时间，并将计数器置为0
            if ((currentTimeMillis - windowInfo.getTime()) > windowSize) {
                windowInfo.getNumber().set(0);
                windowInfo.setTime(currentTimeMillis);
            }
            // 更新当前窗口计数
            if (currentIndex == i && windowInfo.getNumber().get() < qps) {
                windowInfo.getNumber().incrementAndGet();
            }
            sum = sum + windowInfo.getNumber().get();
        }
        // 3. 当前 QPS 是否超过限制
        return sum <= qps;
    }

    private class WindowInfo {
        // 窗口开始时间
        private Long time;
        // 计数器
        private AtomicInteger number;

        public WindowInfo(long time, AtomicInteger number) {
            this.time = time;
            this.number = number;
        }
        // get...set...
    }
}
```

滑动窗口算法虽然解决了固定窗口的临界问题，但**无法应对突发的流量增长**。一旦到达限流阈值后，请求都会被直接被拒绝，这样的话我们会损失一部分请求。

## 7.3 漏桶算法

漏桶算法的原理很简单，可以认为就是注水漏水的过程。往漏桶中以**任意速率**流入水，以**固定速率**流出水。当水超过桶的容量时，会溢出，也就是被丢弃。

![](分布式/fig25.jpg)

流入的水滴可以看作是访问系统的请求，而水滴流出的速率是恒定的，对应服务按照固定的速率处理请求。

伪代码如下：

```java
 /**
     * 每秒处理数（出水率）
     */
    private long rate;

    /**
     *  当前剩余水量
     */
    private long currentWater;

    /**
     * 最后刷新时间
     */
    private long refreshTime;

    /**
     * 桶容量
     */
    private long capacity;

    /**
     * 漏桶算法
     * @return
     */
    boolean leakybucketLimitTryAcquire() {
        long currentTime = System.currentTimeMillis();  //获取系统当前时间
        long outWater = (currentTime - refreshTime) / 1000 * rate; //流出的水量 =(当前时间-上次刷新时间)* 出水率
        long currentWater = Math.max(0, currentWater - outWater); // 当前水量 = 之前的桶内水量-流出的水量
        refreshTime = currentTime; // 刷新时间

        // 当前剩余水量还是小于桶的容量，则请求放行
        if (currentWater < capacity) {
            currentWater++;
            return true;
        }
        
        // 当前剩余水量大于等于桶的容量，限流
        return false;
    }
```

**漏桶的漏出速率是固定的，可以起到整流的作用**。虽然请求的流量可能具有随机性，忽大忽小，但是经过漏桶算法之后，变成了有固定速率的稳定流量，从而对下游的系统起到保护作用。

然而，这一特点即可以是优点也可以是缺点，在面对突发流量时，我们往往会希望在保持系统稳定的同时，能更快的处理用户请求以提升用户体验，而不是按部就班的佛系工作。

## 7.4 令牌桶算法

面对突发流量的时候，我们可以使用令牌桶算法进行限流。

令牌桶算法原理：

- 以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃。
- 请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理。
- 如果令牌桶中没有令牌，则将请求丢弃。

![](分布式/fig26.png)

漏桶算法伪代码如下：

```java
    /**
     * 每秒处理数（放入令牌数量）
     */
    private long putTokenRate;
    
    /**
     * 最后刷新时间
     */
    private long refreshTime;

    /**
     * 令牌桶容量
     */
    private long capacity;
    
    /**
     * 当前桶内令牌数
     */
    private long currentToken = 0L;

    /**
     * 漏桶算法
     * @return
     */
    boolean tokenBucketTryAcquire() {

        long currentTime = System.currentTimeMillis();  //获取系统当前时间
        long generateToken = (currentTime - refreshTime) / 1000 * putTokenRate; //生成的令牌 =(当前时间-上次刷新时间)* 放入令牌的速率
        currentToken = Math.min(capacity, generateToken + currentToken); // 当前令牌数量 = 之前的桶内令牌数量+放入的令牌数量
        refreshTime = currentTime; // 刷新时间
        
        //桶里面还有令牌，请求正常处理
        if (currentToken > 0) {
            currentToken--; //令牌数量-1
            return true;
        }
        
        return false;
    }
```

当请求较多时，令牌桶中的令牌生成一个就会被获取走，与漏桶算法的限流效果相同。但是如果有一段时间没有请求到来，令牌桶中会存储一定的令牌，这时候如果到来大量请求，会获取完令牌桶的所有令牌，从而得到执行，而不是像漏桶算法中始终以固定速率处理请求。

## 7.5 总结

因为计数器算法一般都会采用滑动窗口计数器，所以这里我们对比三种算法。

![](分布式/fig27.png)

其中，Gateway采用了基于Redis实现的令牌桶算法。

而Sentinel内部却比较复杂：

- 默认限流模式是基于滑动时间窗口算法。
- 排队等待的限流模式则是基于漏桶算法。
- 热点参数限流则是基于令牌桶算法。

**参考资料**：

[面试必备：4种经典限流算法讲解](https://z.itpub.net/article/detail/B049B6F216829EDD0827E97BC1AA9100)

[一文搞懂高频面试题之限流算法，从算法原理到实现，再到对比分析](https://juejin.cn/post/6870396751178629127)

[五种限流算法，七种限流方式，挡住突发流量？](https://www.51cto.com/article/704304.html)

[服务器三种常见的限流算法](https://zhuanlan.zhihu.com/p/479956069)

# 8 负载均衡算法

所谓负载均衡就是将外部发送过来的请求均匀或者根据某种算法分配到某一台服务器中。主要的负载均衡算法包括随机、轮询以及一致性哈希。

## 8.1 随机

随机又可以分为完全随机和加权随机。

### 8.1.1 完全随机

所谓完全随机就是完全没有规律可言，每次随机从IP列表中选取一个，将请求打到该服务器上。

```java
public class FullRandom {
    private static Servers servers = new Servers();
    private static Random random = new Random();

    public  static String  getServer() {
        var number = random.nextInt(servers.list.size());
        return servers.list.get(number);
    }
}
```

完全随机是最简单的负载均衡算法了，实现起来也很简单。但是我们在日常生产过程中，机器的处理效率肯定是不同的，有些机器处理的块，有些机器处理的慢。我们希望性能好的服务器多处理些请求，性能差的服务器少处理一些请求，所以就有了加权随机。

### 8.1.2 加权随机

加权随机虽然还是采用的随机算法，但是为每台服务器设置了权重，权重越大的服务器被获取的概率越大。

加权随机算法主要有两种实现方式。

一种是构建一个服务器`List`，如果A服务器的权重是2，那么往`List`里面`add`两次A服务器，如果B服务器的权重是7，那么往`List`里面`add`7次B服务器，以此类推。然后生成一个随机数作为索引从`List`中取服务器，随机数的上限就是权重的总和，也就是`List`的`size`。这样的话，权重越大的服务器被选中的概率越高。

```java
public class ServerIps {
    
    private static final Map<String, Integer> WEIGHT_LIST = new LinkedHashMap<String, Integer>();
    
    static {
        WEIGHT_LIST.put("192.168.0.1", 1);
        WEIGHT_LIST.put("192.168.0.2", 8);
        WEIGHT_LIST.put("192.168.0.3", 3);
        WEIGHT_LIST.put("192.168.0.4", 6);
        WEIGHT_LIST.put("192.168.0.5", 5);
    }
}

public class WeightRandom {
    
    public static String getServer() {
        // 构建一个新的List
        List<String> ips = new ArrayList<>();
        
        // 这里其实可以放在静态代码块中构建，而不用每次获取server都构建一次
        for(String ip : ServerIps.WEIGHT_LIST.keySet()) {
            Integer weight = ServerIps.WEIGHT_LIST.get(ip);
            
            for(int i = 0; i < weight; i++) {
                ips.add(ip);
            }
        }
        
        java.util.Random random = new java.util.Random();
        int randomPos = random.nextInt(ips.size());
        
        return ips.get(randomPos);
    }
}
```

这种实现方式相对比较简单，很容易就可以想到，但是缺点也很明显。如果服务器的权重设置的很大，比如上千上万，那么服务器`List`中也会有上万条数据，白白占用内存。当然，这里可以使用`intern()`进行优化，但是栈中的引用仍然要占据内存空间。

所以就有了第二个方法。假设我们现在有3台服务器，A服务器的权重为$3$，B服务器的权重为$5$，C服务器的权重为$1$，然后我们随机生成一个数：

- 如果生成的随机数为$1$，$1 < 3$（$3$为A的权重），那么此时请求落在A的区间段，请求应该交给A来处理。
- 如果生成的随机数为$5$，那么此时$5 > 3$，所以不在A区间，而$5 - 3 = 2 < 5$（后面的$5$为B的权重），那么此时应该落在B区间。
- 如果生成的随机数为$9$，$9 > 3 + 5$，所以不可能落在A区间或B区间，而$9 - 3 - 5 = 1 \le 1$（后面的$1$为C的权重），落在C区间。

示意图如下，假设下面的数组下标从$1$开始：

![](分布式/fig28.png)

当然我们不可能真的像这张图里面再去维护一个数组，那样就变成第一种方法了。所以每次一个随机数过来后，我们会先去判断它是否小于A的权重：

- 如果小于，那么说明该随机数落在A这一区间，将请求发到A。
- 如果不小于，将随机数减去A的权重，然后在下一次循环中再和B的权重比，就这样循环往复，直到找到对应的区间为止。

代码如下：

```java
public class WeightRandom {
    private static Servers servers = new Servers();
    private static Random random = new Random();

    public static String getServer() {
        int allWeight = servers.map.values().stream().mapToInt(a -> a).sum();
        var number = random.nextInt(allWeight);
        for (var item : servers.map.entrySet()) {
            if (item.getValue() >= number) {
                return item.getKey();
            }
            number -= item.getValue();
        }
        return "";
    }
}
```

这种实现方式相较于第一种是没有内存浪费的，但是如果服务器数量过多的话，速度可能会比第一种方式慢一些。

## 8.2 轮询

轮询又分为三种：完全轮询、加权轮询以及平滑加权轮询。

### 8.2.1 完全轮询

完全轮询的思想十分简单，其实就是轮着来，这次请求打到A上，下次就到B了，再下次就是C了。

```java
public class FullRound {

    private static Servers servers = new Servers();
    private static int index;

    public static String getServer() {
        if (index == servers.list.size()) {
            index = 0;
        }
        return servers.list.get(index++);
    }
}
```

完全轮询的缺点与完全随机基本类似，所以就有了加权轮询。

### 8.2.2 加权轮询

类似于加权随机，加权轮询的实现方式同样有两种，这里演示较好的一种。

```java
public class WeightRound {

    private static Servers servers = new Servers();

    private static int index = 0;

    public static String getServer() {
        // 这里可以提前算好，而不是每次都要重新算一次
        int allWeight = servers.map.values().stream().mapToInt(a -> a).sum();
        int number = (index++) % allWeight;
        for (var item : servers.map.entrySet()) {
            if (item.getValue() > number) {
                return item.getKey();
            }
            number -= item.getValue();
        }
        return "";
    }
}

```



**参考资料**：

[【负载均衡】常见的负载均衡算法的实现与应用 ](https://www.cnblogs.com/jojop/p/13997273.html)

[浅谈负载均衡算法与实现](https://juejin.cn/post/6844903793012768781#heading-7)

